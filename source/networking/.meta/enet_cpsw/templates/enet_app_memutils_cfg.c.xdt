%%{
    let module = system.modules["/networking/enet_cpsw/enet_cpsw"];
%%}
% let instance = module.$instances[0];
/*
 * Enet DMA memory allocation utility functions.
 */

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include <string.h>

#include <enet.h>
#include <include/core/enet_utils.h>

#include <include/core/enet_dma.h>

#include "enet_appmemutils.h"
#include "enet_appmemutils_cfg.h"
#include "enet_apputils.h"

#define PKT_POOL_ENABLE `Number(instance.PktPoolEnable)`U
/* ========================================================================== */
/*                         Structure Declarations                             */
/* ========================================================================== */

#if defined (ENET_SOC_HOSTPORT_DMA_TYPE_UDMA)
/* Enet UDMA DESC memories */
static EnetMem_DmaDescMemPoolEntry gDmaDescMemArray[(((`instance.TxPacketsCount`U) * ENET_CFG_TX_CHANNELS_NUM) +
                            ((`instance.RxPacketsCount`U) * ENET_CFG_RX_FLOWS_NUM))]
__attribute__ ((aligned(ENETDMA_CACHELINE_ALIGNMENT),
                section(".bss:ENET_DMA_DESC_MEMPOOL")));

/* RX & TX RingAcc memories */
static EnetMem_RingMemPoolEntry gRingMemArray[((`instance.RingsTypes`U) *
                                    (ENET_CFG_TX_CHANNELS_NUM + ENET_CFG_RX_FLOWS_NUM))]
__attribute__ ((aligned(ENETDMA_CACHELINE_ALIGNMENT),
                section(".bss:ENET_DMA_RING_MEMPOOL")));
#endif

#if (PKT_POOL_ENABLE == 1)
/* Eth packet info memory Q - large pool */
static EnetDma_Pkt gAppPktInfoMem_LargePool[(((`instance.RxPacketsCount`U) * ENET_CFG_RX_FLOWS_NUM) +
     ((`instance.TxPacketsCount`U) * ENET_CFG_TX_CHANNELS_NUM))];

/* Eth packet large pool memories */
static uint8_t gEthPktMem_LargePool[(((`instance.RxPacketsCount`U) * ENET_CFG_RX_FLOWS_NUM) +
     ((`instance.TxPacketsCount`U) * ENET_CFG_TX_CHANNELS_NUM))][ENET_MEM_LARGE_POOL_PKT_SIZE]
__attribute__ ((aligned(ENETDMA_CACHELINE_ALIGNMENT),
                section(".bss:ENET_DMA_PKT_MEMPOOL")));
#endif

static const EnetMem_Cfg gEthMemCfg =
{
#if (PKT_POOL_ENABLE == 1)
    .pktBufPool =
    {
        [ENET_MEM_POOLIDX_LARGE] =
        {
            .pktSize     = ENET_MEM_LARGE_POOL_PKT_SIZE,
            .numPkts     = (((`instance.RxPacketsCount`U) * ENET_CFG_RX_FLOWS_NUM) +
     ((`instance.TxPacketsCount`U) * ENET_CFG_TX_CHANNELS_NUM)),
            .pktInfoMem  = gAppPktInfoMem_LargePool,
            .pktInfoSize = sizeof(gAppPktInfoMem_LargePool),
            .pktBufMem   = &gEthPktMem_LargePool[0][0],
            .pktBufSize  = sizeof(gEthPktMem_LargePool),
        },
    },
#else
    .pktBufPool =
    {
        [ENET_MEM_POOLIDX_LARGE] =
        {
            .pktSize     = 0,
            .numPkts     = 0,
            .pktInfoMem  = NULL,
            .pktInfoSize = 0,
            .pktBufMem   = NULL,
            .pktBufSize  = 0,
        },
    },
#endif
#if defined (ENET_SOC_HOSTPORT_DMA_TYPE_UDMA)
    .ringMem =
    {
        .numRings    =  ((`instance.RingsTypes`U) *
                                    (ENET_CFG_TX_CHANNELS_NUM + ENET_CFG_RX_FLOWS_NUM)),
        .ringMemBase =  gRingMemArray,
        .ringMemSize =  sizeof(gRingMemArray),
    },
    .dmaDescMem =
    {
        .numDesc     = (((`instance.TxPacketsCount`U) * ENET_CFG_TX_CHANNELS_NUM) +
                            ((`instance.RxPacketsCount`U) * ENET_CFG_RX_FLOWS_NUM)),
        .descMemBase = gDmaDescMemArray,
        .descMemSize = sizeof(gDmaDescMemArray),
    },
#endif
};

const EnetMem_Cfg * EnetMem_getCfg(void)
{
    return &gEthMemCfg;
}