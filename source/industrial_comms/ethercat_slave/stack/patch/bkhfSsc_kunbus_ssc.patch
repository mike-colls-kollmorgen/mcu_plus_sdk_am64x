
diff --git a/SlaveFiles/src/EtherCATSampleLibrary.h b/SlaveFiles/src/EtherCATSampleLibrary.h
index 62712b7..6477474 100644
--- a/SlaveFiles/src/EtherCATSampleLibrary.h
+++ b/SlaveFiles/src/EtherCATSampleLibrary.h
@@ -12,23 +12,6 @@
 ------                                                                                                                                                                 ------
 -----------------------------------------------------------------------------------------*/

-#include <windows.h>
-
-#ifdef __cplusplus
-#ifdef IMPL_OR_EXTERN
-#define EXPORT extern "C" __declspec (dllexport)
-#else
-#define EXPORT extern "C" __declspec (dllimport)
-#endif
-#else
-#ifdef IMPL_OR_EXTERN
-#define EXPORT __declspec (dllexport)
-#else
-#define EXPORT __declspec (dllimport)
-#endif
-#endif
-
-
 typedef struct
 {
     unsigned long * pInput;
@@ -40,8 +23,8 @@ typedef struct
 ECAT_SLAVE_INTERFACE, *pECAT_SLAVE_INTERFACE;


-EXPORT pECAT_SLAVE_INTERFACE __stdcall Ecat_Open(unsigned short InputSize, unsigned short OutputSize);
+pECAT_SLAVE_INTERFACE Ecat_Open(unsigned short InputSize, unsigned short OutputSize);

-EXPORT void __stdcall Ecat_OnTimer(void);
+void Ecat_OnTimer(void);

-EXPORT void __stdcall Ecat_Close(void);
+void Ecat_Close(void);
diff --git a/SlaveFiles/src/SampleApplicationInterface.c b/SlaveFiles/src/SampleApplicationInterface.c
index 9b6bda3..89c6ec8 100644
--- a/SlaveFiles/src/SampleApplicationInterface.c
+++ b/SlaveFiles/src/SampleApplicationInterface.c
@@ -242,6 +242,8 @@ UINT16 APPL_StopOutputHandler(void)
 *////////////////////////////////////////////////////////////////////////////////////////
 UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
 {
+	*pInputSize = 4;
+	*pOutputSize = 4;
     return ALSTATUSCODE_NOERROR;
 }

@@ -399,7 +401,7 @@ UINT16 APPL_GetDeviceID()
 }
 #endif

-pECAT_SLAVE_INTERFACE _stdcall Ecat_Open(unsigned short InputSize, unsigned short OutputSize)
+pECAT_SLAVE_INTERFACE Ecat_Open(unsigned short InputSize, unsigned short OutputSize)
 {
     UINT16 result = 0;
     UINT16 counter = 0;
@@ -588,7 +590,7 @@ pECAT_SLAVE_INTERFACE _stdcall Ecat_Open(unsigned short InputSize, unsigned shor
    return &SlaveInterface;
 }

-void __stdcall Ecat_OnTimer(void)
+void Ecat_OnTimer(void)
 {
     if(HardwareOpened == 0)
         return;
@@ -596,7 +598,7 @@ void __stdcall Ecat_OnTimer(void)
     MainLoop();
 }

-void __stdcall Ecat_Close(void)
+void Ecat_Close(void)
 {
     if(HardwareOpened == 0)
         return;
diff --git a/SlaveFiles/src/bootmode.c b/SlaveFiles/src/bootmode.c
index aeda9bf..84cf033 100644
--- a/SlaveFiles/src/bootmode.c
+++ b/SlaveFiles/src/bootmode.c
@@ -27,6 +27,9 @@ V4.20: File created
 ------
 --------------------------------------------------------------------------------------*/
 #include "ecat_def.h"
+#if TIESC_HW
+#include "tiescbsp.h"
+#endif
 #if BOOTSTRAPMODE_SUPPORTED


@@ -67,6 +70,11 @@ void BL_Stop(void)
 *////////////////////////////////////////////////////////////////////////////////////////
 void BL_StartDownload(UINT32 password)
 {
+#if TIESC_HW
+#ifdef ENABLE_ONLINE_FIRMWARE_UPGRADE
+    bsp_start_fw_download(password);
+#endif
+#endif
 }
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
@@ -80,6 +88,11 @@ void BL_StartDownload(UINT32 password)
 *////////////////////////////////////////////////////////////////////////////////////////
 UINT16 BL_Data(UINT16 *pData,UINT16 Size)
 {
+#if TIESC_HW
+#ifdef ENABLE_ONLINE_FIRMWARE_UPGRADE
+    bsp_store_fw_data(pData,Size);
+#endif
+#endif
     return 0;
 }
 #endif //BOOTSTRAPMODE_SUPPORTED
diff --git a/SlaveFiles/src/cia402appl.c b/SlaveFiles/src/cia402appl.c
index df73e28..2bad980 100644
--- a/SlaveFiles/src/cia402appl.c
+++ b/SlaveFiles/src/cia402appl.c
@@ -56,6 +56,24 @@ V4.30 : create file (state machine; handling state transition options; input fee
 #include "cia402appl.h"
 #undef _CiA402_

+#if TIESC_HW
+#include "tiescutils.h"
+#endif
+
+#ifdef CiA402_MOTOR_CONTROL
+#include <motor_control/control/math_blocks/IQmathLib.h>
+
+#include <motor_control/control/foc/foc.h>
+extern volatile STRUCT_FOC_PARAMS *p_mem_foc_params;
+extern Uint32 ElecThetaCalibrateFlag;
+#define LSW_CURRENT 1
+#define LSW_ENDAT 2
+#define CURRENT_LSW LSW_ENDAT
+#define SPEED_EPSILON 1e-3
+
+#define TWINCAT_SINGLE_TURN_RES pow(2, 20)
+#define TWINCAT_VELOCITY_RES pow(2, 20)
+#endif

 /*--------------------------------------------------------------------------------------
 ------
@@ -90,6 +108,13 @@ UINT16 CiA402_Init(void)
     UINT32 ObjectOffset = 0x800;
     UINT8 PDOOffset = 0x10;

+// currently supports only one axis per board
+#ifdef CiA402_MOTOR_CONTROL
+    int32_t val;
+    setECAT_lsw(0);
+    setECAT_ChannelSel(0);    // set depending on the mode - csv / csp
+#endif
+
     for(AxisCnt = 0; AxisCnt < MAX_AXES ; AxisCnt++)
     {
         /*Reset Axis buffer*/
@@ -338,12 +363,18 @@ void CiA402_StateMachine(void)
         if (pCiA402Axis->i16State < STATE_READY_TO_SWITCH_ON && nAlStatus == STATE_OP)
         {
             pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON;
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
         }

         switch(pCiA402Axis->i16State)
         {
         case STATE_NOT_READY_TO_SWITCH_ON:
             StatusWord |= (STATUSWORD_STATE_NOTREADYTOSWITCHON);
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
             if(nAlStatus == STATE_OP)
             {
                 // Automatic transition -> Communication shall be activated
@@ -360,6 +391,9 @@ void CiA402_StateMachine(void)
             break;
         case STATE_SWITCH_ON_DISABLED:
             StatusWord |= (STATUSWORD_STATE_SWITCHEDONDISABLED);
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
             if ((ControlWord6040 & CONTROLWORD_COMMAND_SHUTDOWN_MASK) == CONTROLWORD_COMMAND_SHUTDOWN)
             {
                 pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 2
@@ -367,6 +401,9 @@ void CiA402_StateMachine(void)
             break;
         case STATE_READY_TO_SWITCH_ON:
             StatusWord |= (STATUSWORD_STATE_READYTOSWITCHON);
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
             if (((ControlWord6040 & CONTROLWORD_COMMAND_QUICKSTOP_MASK) == CONTROLWORD_COMMAND_QUICKSTOP)
                 || ((ControlWord6040 & CONTROLWORD_COMMAND_DISABLEVOLTAGE_MASK) == CONTROLWORD_COMMAND_DISABLEVOLTAGE))
             {
@@ -380,7 +417,9 @@ void CiA402_StateMachine(void)
                 break;
         case STATE_SWITCHED_ON:
             StatusWord |= (STATUSWORD_STATE_SWITCHEDON);
-
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
             if ((ControlWord6040 & CONTROLWORD_COMMAND_SHUTDOWN_MASK) == CONTROLWORD_COMMAND_SHUTDOWN)
             {
                 pCiA402Axis->i16State = STATE_READY_TO_SWITCH_ON; // Transition 6
@@ -401,6 +440,9 @@ void CiA402_StateMachine(void)
         case STATE_OPERATION_ENABLED:
             StatusWord |= (STATUSWORD_STATE_OPERATIONENABLED);

+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(CURRENT_LSW);       // set ECAT_lsw = 1 for current feedback = 2 for EnDat feedback
+#endif
             if ((ControlWord6040 & CONTROLWORD_COMMAND_DISABLEOPERATION_MASK) == CONTROLWORD_COMMAND_DISABLEOPERATION)
             {
                 if(pCiA402Axis->Objects.objDisableOperationOptionCode!= DISABLE_DRIVE)
@@ -435,6 +477,9 @@ void CiA402_StateMachine(void)
         case STATE_QUICK_STOP_ACTIVE:
             StatusWord |= STATUSWORD_STATE_QUICKSTOPACTIVE;

+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(CURRENT_LSW);       // set ECAT_lsw = 1 for current feedback = 2 for EnDat feedback
+#endif
             if((pCiA402Axis->Objects.objQuickStopOptionCode != DISABLE_DRIVE) &&
                 ((pCiA402Axis->Objects.objStatusWord & STATUSWORD_STATE_MASK)!= STATUSWORD_STATE_QUICKSTOPACTIVE))
             {
@@ -452,6 +497,9 @@ void CiA402_StateMachine(void)
             break;
         case STATE_FAULT_REACTION_ACTIVE:
             StatusWord |= (STATUSWORD_STATE_FAULTREACTIONACTIVE);
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(CURRENT_LSW);       // set ECAT_lsw = 1 for current feedback = 2 for EnDat feedback
+#endif
             if(pCiA402Axis->Objects.objFaultReactionCode!= DISABLE_DRIVE)
             {
                 /*fault reaction pending*/
@@ -464,7 +512,9 @@ void CiA402_StateMachine(void)
             break;
         case STATE_FAULT:
             StatusWord |= (STATUSWORD_STATE_FAULT);
-
+#ifdef CiA402_MOTOR_CONTROL
+            setECAT_lsw(0);
+#endif
             if ((ControlWord6040 & CONTROLWORD_COMMAND_FAULTRESET_MASK) == CONTROLWORD_COMMAND_FAULTRESET)
             {
                 pCiA402Axis->i16State = STATE_SWITCH_ON_DISABLED;// Transition 15
@@ -553,6 +603,84 @@ void CiA402_LocalError(UINT16 ErrorCode)
     }
 }

+#ifdef CiA402_MOTOR_CONTROL
+void CiA402_MotionControl(TCiA402Axis *pCiA402Axis)
+{
+    INT32 i32TargetVelocity = 0, i32TargetPosition = 0;
+
+    /*Motion Controller shall only be triggered if application is trigger by DC Sync Signals,
+    and a valid mode of operation is set*/
+
+    /* Currently, multi-turn not supported by LEVEL5 in motor control application
+     * So, for csp mode, use single_turn_angle
+     */
+    switch(pCiA402Axis->Objects.objModesOfOperationDisplay) {
+        case CYCLIC_SYNC_POSITION_MODE:
+            pCiA402Axis->fCurPosition = foc_get_single_turn_angle() * TWINCAT_SINGLE_TURN_RES;
+            break;
+        case CYCLIC_SYNC_VELOCITY_MODE:
+            pCiA402Axis->fCurPosition = foc_get_multi_turn_angle() * TWINCAT_SINGLE_TURN_RES;
+            break;
+        }
+    pCiA402Axis->Objects.objPositionActualValue = pCiA402Axis->fCurPosition;
+
+    if(pCiA402Axis->bAxisFunctionEnabled &&
+    pCiA402Axis->bLowLevelPowerApplied &&
+    pCiA402Axis->bHighLevelPowerApplied &&
+    !pCiA402Axis->bBrakeApplied)
+    {
+        if((pCiA402Axis->Objects.objSoftwarePositionLimit.i32MaxLimit> pCiA402Axis->Objects.objPositionActualValue
+            || pCiA402Axis->Objects.objPositionActualValue > pCiA402Axis->Objects.objTargetPosition) &&
+            (pCiA402Axis->Objects.objSoftwarePositionLimit.i32MinLimit < pCiA402Axis->Objects.objPositionActualValue
+            || pCiA402Axis->Objects.objPositionActualValue < pCiA402Axis->Objects.objTargetPosition))
+        {
+            pCiA402Axis->Objects.objStatusWord &= ~STATUSWORD_INTERNAL_LIMIT;
+
+            switch(pCiA402Axis->Objects.objModesOfOperationDisplay)
+            {
+            case CYCLIC_SYNC_POSITION_MODE:
+                if(pCiA402Axis->i16State == STATE_OPERATION_ENABLED) {
+                    i32TargetPosition = pCiA402Axis->Objects.objTargetPosition;
+                    setECAT_lsw(CURRENT_LSW);
+                    setECAT_SpeedRef((float)i32TargetPosition / (TWINCAT_SINGLE_TURN_RES));
+                }
+                else
+                    setECAT_lsw(0);
+                break;
+            case CYCLIC_SYNC_VELOCITY_MODE:
+                if(pCiA402Axis->i16State == STATE_OPERATION_ENABLED)
+                    i32TargetVelocity = pCiA402Axis->Objects.objTargetVelocity;
+                else
+                        i32TargetVelocity = 0;
+                //setECAT_SpeedRef takes input as velocity in RPM/4000
+                setECAT_SpeedRef((float)i32TargetVelocity / ((float)4000 * (float)TWINCAT_VELOCITY_RES));
+                setECAT_lsw(CURRENT_LSW);
+
+                break;
+            default:
+                break;
+            }
+        }
+        else
+        {
+            pCiA402Axis->Objects.objStatusWord |= STATUSWORD_INTERNAL_LIMIT;
+        }
+    }
+    /*Accept new mode of operation*/
+    pCiA402Axis->Objects.objModesOfOperationDisplay = pCiA402Axis->Objects.objModesOfOperation;
+    // take care of the cases in which change of mode is allowed
+    switch(pCiA402Axis->Objects.objModesOfOperationDisplay) {
+    case CYCLIC_SYNC_POSITION_MODE:
+        setECAT_ChannelSel(1);
+        break;
+    case CYCLIC_SYNC_VELOCITY_MODE:
+        setECAT_ChannelSel(0);
+        break;
+    }
+
+}
+#endif
+
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
  \brief    CiA402_DummyMotionControl
@@ -630,45 +758,70 @@ void CiA402_DummyMotionControl(TCiA402Axis *pCiA402Axis)
 *////////////////////////////////////////////////////////////////////////////////////////
 BOOL CiA402_TransitionAction(INT16 Characteristic,TCiA402Axis *pCiA402Axis)
 {
+#ifdef CiA402_MOTOR_CONTROL
+   // Behaviour of STOP_ON_CURRENT/VOLTAGE_LIMIT same as other two.
+   setUseRamp(1);
+   float cur_speed = p_mem_foc_params->mem_speed * (float)4000;
+
    switch(Characteristic)
    {

    case SLOW_DOWN_RAMP:
-#if _WIN32
-      #pragma message ("Warning: Implement slowdown ramp")
-#else
-      #warning "Implement slowdown ramp"
-#endif
-      return TRUE;
-      break;
+		setECAT_ChannelSel(0);
+        setECAT_lsw(CURRENT_LSW);
+        setECAT_SpeedRef(0);
+        if (cur_speed < SPEED_EPSILON) {
+            setUseRamp(0);
+            return TRUE;
+        }
+        else {
+          return FALSE;
+        }
+        break;
    case QUICKSTOP_RAMP:
-#if _WIN32
-      #pragma message ("Warning: Implement quick stop ramp ramp")
-#else
-      #warning "Implement quick stop ramp ramp"
-#endif
-      return TRUE;
-      break;
+		setECAT_ChannelSel(0);
+        setECAT_lsw(CURRENT_LSW);
+        setECAT_SpeedRef(0);
+        if (cur_speed < SPEED_EPSILON) {
+            setUseRamp(0);
+            return TRUE;
+        }
+        else {
+            return FALSE;
+        }
+        break;
    case STOP_ON_CURRENT_LIMIT:
-#if _WIN32
-      #pragma message ("Warning: Implement slowdown on current limit ramp")
-#else
-      #warning "Implement slowdown on current limit ramp"
-#endif
-      return TRUE;
-      break;
+		setECAT_ChannelSel(0);
+		setECAT_lsw(CURRENT_LSW);
+        setECAT_SpeedRef(0);
+        if (cur_speed < SPEED_EPSILON) {
+            setUseRamp(0);
+            return TRUE;
+        }
+        else {
+           return FALSE;
+        }
+        break;
    case STOP_ON_VOLTAGE_LIMIT:
-#if _WIN32
-      #pragma message ("Warning: Implement slowdown on voltage limit ramp")
-#else
-      #warning "Implement slowdown on voltage limit ramp"
-#endif
-      return TRUE;
-      break;
+		setECAT_ChannelSel(0);
+        setECAT_lsw(CURRENT_LSW);
+        setECAT_SpeedRef(0);
+        if (cur_speed < SPEED_EPSILON) {
+            setUseRamp(0);
+            return TRUE;
+        }
+        else {
+          return FALSE;
+        }
+        break;
    default:
       break;
-   }
-    return FALSE;
+	}
+
+	return FALSE;
+#else
+   return TRUE;
+#endif
 }

 /////////////////////////////////////////////////////////////////////////////////////////
@@ -779,11 +932,12 @@ void CiA402_Application(TCiA402Axis *pCiA402Axis)
         && (pCiA402Axis->u32CycleTime != 0)
         && ((pCiA402Axis->Objects.objSupportedDriveModes >> (pCiA402Axis->Objects.objModesOfOperation - 1)) & 0x1)) //Mode of Operation (0x6060) - 1 specifies the Bit within Supported Drive Modes (0x6502)
     {
+#ifdef CiA402_MOTOR_CONTROL
+        CiA402_MotionControl(pCiA402Axis);
+#else
         CiA402_DummyMotionControl(pCiA402Axis);
-    }
-
-
-
+#endif
+	}
 }


@@ -1473,6 +1627,9 @@ UINT16 APPL_GetDeviceID(void)
 *////////////////////////////////////////////////////////////////////////////////////////
 int main(void)
 {
+#if TIESC_HW
+    common_main();
+#else
     /* initialize the Hardware and the EtherCAT Slave Controller */
     HW_Init();

@@ -1493,6 +1650,7 @@ int main(void)
     CiA402_DeallocateAxis();

     HW_Release();
+#endif
     return 0;
 }
 #endif //#if USE_DEFAULT_MAIN
diff --git a/SlaveFiles/src/cia402appl.h b/SlaveFiles/src/cia402appl.h
index c9d89b0..0e1f9fc 100644
--- a/SlaveFiles/src/cia402appl.h
+++ b/SlaveFiles/src/cia402appl.h
@@ -1064,7 +1064,7 @@ OBJCONST UCHAR OBJMEM aName0xF050[] = "Module detected list";
  */
 PROTO TOBJ1C12 sRxPDOassign
 #ifdef _CiA402_
-= {1,{0x1602,0x0}}
+= {1,{0x1600,0x0}}
 #endif
 ;

@@ -1078,7 +1078,7 @@ PROTO TOBJ1C12 sRxPDOassign
  */
 PROTO TOBJ1C13 sTxPDOassign
 #ifdef _CiA402_
-= {1,{0x1A02,0x0}}
+= {1,{0x1A00,0x0}}
 #endif
 ;
 /** @}*/
@@ -1124,7 +1124,7 @@ PROTO TOBJF010 sModuleProfileInfo
  */
 PROTO TOBJF030 sConfiguredModuleIdentList
 #ifdef _CiA402_
-= {1,{0x319800,0}}
+= {1,{0x119800,0}}
 #endif
 ;

@@ -1140,7 +1140,7 @@ PROTO UINT8 Write0xF030( UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 M
  */
 PROTO TOBJF050 sDetectedModuleIdentList
 #ifdef _CiA402_
-= {1,{0x319800,0}}
+= {1,{0x119800,0}}
 #endif
 ;
 /** @}*/
diff --git a/SlaveFiles/src/coeappl.c b/SlaveFiles/src/coeappl.c
index e6931d4..7bcd2ab 100644
--- a/SlaveFiles/src/coeappl.c
+++ b/SlaveFiles/src/coeappl.c
@@ -137,8 +137,11 @@ V4.00 ECAT 1: The handling of the Sync Manager Parameter was included according
 #include "testappl.h"
 #elif SAMPLE_APPLICATION_INTERFACE
 #include "SampleApplicationInterface.h"
+#elif KUNBUS_STACK_APPLICATION
+#include <ssc_kbStack.h>
 #else
 /*CODE_INSERT_START (APPLICATION_FILE)*/
+#include "tiescappl.h"
 /*CODE_INSERT_END*/
 #endif

@@ -299,7 +302,7 @@ OBJCONST UCHAR OBJMEM aName0x1010[] = "Store parameters";

 UINT8 Write0x1010( UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
 {
-
+
    if ( bCompleteAccess )
    {
       /* Complete Access is not supported for object 0x1010 */
@@ -341,7 +344,7 @@ OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x1011[] = {
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READWRITE}};

 /**
- * \brief 0x1011 (Restore default parameters) object name
+ * \brief 0x1011 (Restore default parameters) object name
  */
 OBJCONST UCHAR OBJMEM aName0x1011[] = "Restore default parameters";

@@ -360,7 +363,7 @@ OBJCONST UCHAR OBJMEM aName0x1011[] = "Restore default parameters";
 */
 UINT8 Write0x1011( UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
 {
-
+
    if ( bCompleteAccess )
    {
       /* Complete Access is not supported for object 0x1011 */
@@ -399,7 +402,7 @@ TOBJ1018 sIdentity = {4, (VENDOR_ID), (PRODUCT_CODE), (REVISION_NUMBER), (SERIAL

 /**
  * \brief 0x1018 (Identity) entry descriptions
- *
+ *
  * Subindex 000
  * SubIndex 001: Vendor ID
  * SubIndex 002: Product code
@@ -408,9 +411,9 @@ TOBJ1018 sIdentity = {4, (VENDOR_ID), (PRODUCT_CODE), (REVISION_NUMBER), (SERIAL
  */
 OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x1018[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ },
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ},
    {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READ}};

 /**
@@ -429,7 +432,7 @@ TOBJ10F0 sBackupparameterhandling = {1, 0x00};

 /**
  * \brief 0x10F0 (Backup parameter handling) entry descriptions
- *
+ *
  * Subindex 000
  * SubIndex 001: Checksum
  */
@@ -455,12 +458,12 @@ OBJCONST UCHAR OBJMEM aName0x10F0[] = "Backup parameter handling\000Checksum\000
  */
 OBJCONST TSDOINFOENTRYDESC    OBJMEM asEntryDesc0x10F1[] = {
    {DEFTYPE_UNSIGNED8, 0x8, ACCESS_READ },
-   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READWRITE},
+   {DEFTYPE_UNSIGNED32, 0x20, ACCESS_READWRITE},
    {DEFTYPE_UNSIGNED16, 0x10, ACCESS_READWRITE}};

 /**
  * \brief 0x10F1 (Error settings) object and entry names
- */
+ */
 OBJCONST UCHAR OBJMEM aName0x10F1[] = "Error Settings\000Local Error Reaction\000Sync Error Counter Limit\000\377";


@@ -507,7 +510,7 @@ UINT8 Read0x10F8(UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM *
         return ABORTIDX_PARAM_IS_INCOMPATIBLE;
     }

-
+
     if (bCompleteAccess)
     {
          /* Complete Access is not supported for object 0x10F8 */
@@ -538,7 +541,7 @@ UINT8 Read0x10F8(UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM *
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
 \brief    This function updates the local timestamp object (0x10F8) and has to be called at least every 4.2sec to detect an 32Bit DC unit overrun.
-          Called from the Timer handler
+          Called from the Timer handler
 *////////////////////////////////////////////////////////////////////////////////////////
 void COE_SyncTimeStamp(void)
 {
@@ -558,13 +561,13 @@ void COE_SyncTimeStamp(void)
             /*32Bit overrun*/
             u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
         }
-
+
         u32LastDc32Value = DcTime;
     }
     else
     {
         /*The DC unit supports 64Bit => update the complete object*/
-
+
         HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
     }

@@ -591,7 +594,11 @@ void COE_SyncTimeStamp(void)
  *
  */
  /*ECATCHANGE_START(V5.12)*/
+#if BIG_ENDIAN_FORMAT
 TOBJ1C00 sSyncmanagertype = {0x04, {0x0102, 0x0304}};
+#else
+TOBJ1C00 sSyncmanagertype = {0x04, {0x0201, 0x0403}}; /*1,2,3,4 type in  BYTE order */
+#endif
 /*ECATCHANGE_END(V5.12)*/


@@ -728,7 +735,7 @@ TOBJECT    OBJMEM GenObjDic[] = {
    /* Object 0x1C33 */
    {NULL,NULL, 0x1C33, {DEFTYPE_SMPAR, 32 | (OBJCODE_REC << 8)}, asEntryDesc0x1C3x, aName0x1C33, &sSyncManInPar, NULL, NULL, 0x0000 },
 #endif
-
+
   /*end of entries*/
   {NULL,NULL, 0xFFFF, {0, 0}, NULL, NULL, NULL, NULL, NULL, 0x000}};

@@ -1061,7 +1068,7 @@ void COE_UpdateSyncErrorStatus(void)
     {
         sSyncManInPar.u8SyncError = 0;
     }
-#endif
+#endif

 }
 /*ECATCHANGE_END(V5.12) ECAT5*/
@@ -1149,7 +1156,7 @@ void COE_ObjInit(void)
     /* default mode is ECAT Synchron Mode, if output size > 0 the inputs are updated with the SM2-event */
     sSyncManInPar.u16SyncType         = SYNCTYPE_FREERUN;

-
+
     /* subindex 2: same as 0x1C32:02 */
 #if MAX_PD_OUTPUT_SIZE > 0
     sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
@@ -1439,7 +1446,7 @@ UINT16 COE_ObjDictionaryInit(void)
     {
         return result;
     }
-
+
     if(ApplicationObjDic != NULL)
     {
         result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
@@ -1463,7 +1470,7 @@ void COE_Main(void)
 {
 #if SDO_RES_INTERFACE
      UINT8 abort = 0;
-
+
     if(pSdoPendFunc != NULL)
     {
         abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 1bad5b4..20e9ab3 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -5,41 +5,50 @@


 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	ecat_def.h
 ------  SSC version : 5.12
 -----------------------------------------------------------------------------------------*/

-#ifndef _ECATDEF_H_
-#define _ECATDEF_H_
+#if !(defined _ECATDEF_H_)
+#define _ECATDEF_H_     1

 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	Includes
-------
+------
 -----------------------------------------------------------------------------------------*/
 #include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
 #include <string.h>
+#include <stdio.h>
+#if defined(SOC_AM65XX)
+#if !defined (__aarch64__)
+/* Only for R5F build. */
+#include <stdint.h>
+#endif
+#endif

 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	Slave Sample Code Configuration Defines
-------
+------
 -----------------------------------------------------------------------------------------*/
 #define SSC_VERSION_MAJOR 5
 #define SSC_VERSION_MINOR 12


-/**
+/**
 EL9800_HW: Shall be set if the Slave code is executed on the PIC mounted on the EL9800 EtherCAT Evaluation Board.<br>
 (if the MCI interface provided by EL9800 board should be used MCI_HW shall be set and this define shall be reset).<br>
 This settings should also be enabled if the ESC is connected via a serial interface and no specific hardware access files are avilable yet.<br>
 NOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
 #ifndef EL9800_HW
-#define EL9800_HW                                 1
+#define EL9800_HW                                 0
 #endif

-/**
+/**
 MCI_HW: Shall be set if the MCI of the ESC is connected.<br>
 This settings should also be enabled if the ESC is connected via a parallel interface and no specific hardware access files are avilable yet.<br>
 NOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
@@ -47,72 +56,72 @@ NOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
 #define MCI_HW                                    0
 #endif

-/**
+/**
 FC1100_HW: Shall be set if the EtherCAT slave controller is located on an FC1100 PCI card.<br>
 NOTE: The PDI type needs also to be configured in the "ESC_CONFIG_DATA". */
 #ifndef FC1100_HW
 #define FC1100_HW                                 0
 #endif

-/**
+/**
 TIESC_HW: Temporary define to support TI ICE/IDK development board (Shall be set if the Slave code shall executed on an AM335X ICE/IDK Evaluation Board<br>
 from Texas Instruments) */
 #ifndef TIESC_HW
-#define TIESC_HW                                  0
+#define TIESC_HW                                  1
 #endif

-/**
+/**
 CONTROLLER_16BIT: Shall be set if the host controller is a 16Bit architecture */
 #ifndef CONTROLLER_16BIT
-#define CONTROLLER_16BIT                          1
+#define CONTROLLER_16BIT                          0
 #endif

-/**
+/**
 CONTROLLER_32BIT: Shall be set if the host controller is a 32Bit architecture */
 #ifndef CONTROLLER_32BIT
 #define CONTROLLER_32BIT                          0
 #endif

-/**
+/**
 _PIC18: Microchip PIC18F452 Specific Code <br>
 This processor is mounted on the Beckhoff Slave Evaluation Board (Hardware version up to EL9800_2). */
 #ifndef _PIC18
 #define _PIC18                                    0
 #endif

-/**
+/**
 _PIC24: Microchip PIC24HJ128GP306 Specific Code <br>
 This processor is mounted on the Beckhoff Slave Evaluation Board (Hardware version up to EL9800_4A). */
 #ifndef _PIC24
-#define _PIC24                                    1
+#define _PIC24                                    0
 #endif

-/**
+/**
 ESC_16BIT_ACCESS: If the microcontroller only supports 16Bit access to the ESC. */
 #ifndef ESC_16BIT_ACCESS
-#define ESC_16BIT_ACCESS                          1
+#define ESC_16BIT_ACCESS                          0
 #endif

-/**
+/**
 ESC_32BIT_ACCESS: If the microcontroller only supports 32Bit access to the ESC. */
 #ifndef ESC_32BIT_ACCESS
 #define ESC_32BIT_ACCESS                          0
 #endif

-/**
+/**
 MBX_16BIT_ACCESS: If the microcontroller only supports 16Bit access to local mailbox memory(access to ESC DPRAM is controlled by "ESC_16BIT_ACCESS"). If reset 8Bit access is used. */
 #ifndef MBX_16BIT_ACCESS
-#define MBX_16BIT_ACCESS                          1
+#define MBX_16BIT_ACCESS                          0
 #endif

-/**
+/**
 BIG_ENDIAN_16BIT: If the microcontroller always make 16 bit access to external memory, operates in BigEndian format<br>
 and the switching of the high and low byte is done in hardware. */
 #ifndef BIG_ENDIAN_16BIT
 #define BIG_ENDIAN_16BIT                          0
 #endif

-/**
+/**
 BIG_ENDIAN_FORMAT: If the microcontroller works with BigEndian format, then this switch shall be set. In that case all WORD-<br>
 and DWORD-accesses will make a BYTE- or WORD-swapping, the macros SWAPWORD and SWAPDWORD in ecatslv.h might be adapted. <br>
 If this switch is set, then BIG_ENDIAN_16BIT shall be reset. */
@@ -120,44 +129,44 @@ If this switch is set, then BIG_ENDIAN_16BIT shall be reset. */
 #define BIG_ENDIAN_FORMAT                         0
 #endif

-/**
+/**
 EXT_DEBUGER_INTERFACE: If this switch is set, the external debugger interface on the EL9800_4A (_PIC24) will be activated.<br>
 This define will be ignored if _PIC24 is not set. */
 #ifndef EXT_DEBUGER_INTERFACE
 #define EXT_DEBUGER_INTERFACE                     0
 #endif

-/**
+/**
 UC_SET_ECAT_LED: If set the EtherCAT Run and Error LEDs are set by the uController. If set ESC_SUPPORT_ECAT_LED shall be reset. */
 #ifndef UC_SET_ECAT_LED
 #define UC_SET_ECAT_LED                           1
 #endif

-/**
+/**
 ESC_SUPPORT_ECAT_LED: This switch can be enabled if the connected ESC support Error and Run LED indication. See the ESC datasheet if the LED indication is supported. If set UC_SET_ECAT_LED shall be reset. */
 #ifndef ESC_SUPPORT_ECAT_LED
 #define ESC_SUPPORT_ECAT_LED                      0
 #endif

-/**
+/**
 ESC_EEPROM_EMULATION: If this switch is set EEPROM emulation is supported. Not all ESC types support EEPROM emulation. See ESC datasheet for more information. */
 #ifndef ESC_EEPROM_EMULATION
-#define ESC_EEPROM_EMULATION                      0
+#define ESC_EEPROM_EMULATION                      1
 #endif

-/**
+/**
 ESC_EEPROM_SIZE: Specify the EEPROM size in Bytes of the connected EEPROM or the emulated EEPROM. */
 #ifndef ESC_EEPROM_SIZE
 #define ESC_EEPROM_SIZE                           0x800
 #endif

-/**
+/**
 EEPROM_WRITE_SIZE: Only required if EEPROM emulation is active. This value defines the number of bytes which will be written per opertion. */
 #ifndef EEPROM_WRITE_SIZE
 #define EEPROM_WRITE_SIZE                         0x2
 #endif

-/**
+/**
 AL_EVENT_ENABLED: If an interrupt routine shall be called when one of the Events in the AL Event Register (0x220) changes, <br>
 this switch has to be defined to 1 (synchronous modes are supported). <br>
 If the AL Event register shall only be polled, this switch has to be defined to 0 (only free run mode is supported). */
@@ -165,7 +174,7 @@ If the AL Event register shall only be polled, this switch has to be defined to
 #define AL_EVENT_ENABLED                          1
 #endif

-/**
+/**
 DC_SUPPORTED: If distributed clocks should be supported by the slave, then this switch shall be set.<br>
 If this switch is set, then also AL_EVENT_ENABLED shall be set.<br>
 NOTE: The DC support needs also be set in the "ESC_CONFIG_DATA" settings. */
@@ -173,13 +182,13 @@ NOTE: The DC support needs also be set in the "ESC_CONFIG_DATA" settings. */
 #define DC_SUPPORTED                              1
 #endif

-/**
+/**
 ECAT_TIMER_INT: If this switch is set, then the watchdog time for the EtherCAT watchdog will be checked in a timer interrupt routine. */
 #ifndef ECAT_TIMER_INT
 #define ECAT_TIMER_INT                            0
 #endif

-/**
+/**
 INTERRUPTS_SUPPORTED: If this switch is set the slave stack provides interrupt handling.<br>
 NOTE: value will be evaluated automatically!! */
 #ifndef INTERRUPTS_SUPPORTED
@@ -190,85 +199,90 @@ NOTE: value will be evaluated automatically!! */
 #endif
 #endif

-/**
+/**
 TEST_APPLICATION: NOTE: THIS SETTING SHALL NOT BE USED TO CREATE A USER SPECIFIC APPLICATION!<br>
 Select this setting to test the slave stack or a master implementation. For further information about this application see the SSC Application Node. */
 #ifndef TEST_APPLICATION
 #define TEST_APPLICATION                          0
 #endif

-/**
+/**
 EL9800_APPLICATION: Should be set if the Slave Sample Code runs on an EL9800_x Evaluation Board. */
 #ifndef EL9800_APPLICATION
-#define EL9800_APPLICATION                        1
+#define EL9800_APPLICATION                        0
 #endif

-/**
+/**
 CiA402_DEVICE: If this switch is set, then the sample implementation of CiA402 device profile will be activated. */
 #ifndef CiA402_DEVICE
 #define CiA402_DEVICE                             0
 #endif

-/**
+/**
 SAMPLE_APPLICATION: Select this define if the hardware independent sample application shall be activated. */
 #ifndef SAMPLE_APPLICATION
 #define SAMPLE_APPLICATION                        0
 #endif

-/**
+/**
 SAMPLE_APPLICATION_INTERFACE: Select this define to activate the Sample Application Interface. This provides an simple interface to create a static library and used in an external application.<br>
 NOTE: The file "EtherCATSampleLibrary.h" includes the library interface (maybe need to be adapted).  */
 #ifndef SAMPLE_APPLICATION_INTERFACE
 #define SAMPLE_APPLICATION_INTERFACE              0
 #endif

-/**
+/**
 BOOTLOADER_SAMPLE: Select this define to enable a small footprint application which only supports the BOOT state and FoE mailbox protocol. */
 #ifndef BOOTLOADER_SAMPLE
 #define BOOTLOADER_SAMPLE                         0
 #endif

-/**
+#ifndef TIESC_APPLICATION
+/*TIESC_APPLICATION: Should be set if the Slave Sample Code runs on an ICE/IDK EVM. */
+#define TIESC_APPLICATION                         1
+#endif
+
+/**
 USE_DEFAULT_MAIN: Set to 1 if the main function of a default application shall be used.<br>
 Otherwise the Init functions and the mainloop handler shall be called for a user specific function (see ET9300 Application Note for further details www.beckhoff.com/english.asp?download/ethercat_development_products.htm?id=71003127100387). */
 #ifndef USE_DEFAULT_MAIN
 #define USE_DEFAULT_MAIN                          1
 #endif

-/**
+/**
 MAILBOX_QUEUE: If this switch is set, the mailbox services will be stored in a queue.<br>
 With this switch reset only one mailbox service can be processed in parallel. */
 #ifndef MAILBOX_QUEUE
 #define MAILBOX_QUEUE                             1
 #endif

-/**
+/**
 AOE_SUPPORTED: If the AoE services are supported, then this switch shall be set. */
 #ifndef AOE_SUPPORTED
 #define AOE_SUPPORTED                             0
 #endif

-/**
+/**
 COE_SUPPORTED: If the CoE services are supported, then his switch shall be set. */
 #ifndef COE_SUPPORTED
 #define COE_SUPPORTED                             1
 #endif

-/**
+/**
 COMPLETE_ACCESS_SUPPORTED: If the complete SDO access (accessing all entries of an object with one SDO service, then this<br>
 switch shall be set. Furthermore,COE_SUPPORTED shall be set. */
 #ifndef COMPLETE_ACCESS_SUPPORTED
 #define COMPLETE_ACCESS_SUPPORTED                 1
 #endif

-/**
+/**
 SEGMENTED_SDO_SUPPORTED: If the segmented SDO services should be supported, then this switch shall be set.<br>
 Furthermore, COE_SUPPORTED shall be set. */
 #ifndef SEGMENTED_SDO_SUPPORTED
 #define SEGMENTED_SDO_SUPPORTED                   1
 #endif

-/**
+/**
 SDO_RES_INTERFACE: If a SDO response cannot be generated immediately (e.g. when access over<br>
 a serial interface is needed), this switch should be set. In that case ABORTIDX_WORKING shall be<br>
 returned from OBJ_Read or OBJ_Write and the response shall be sent by calling SDOS_SdoRes, when<br>
@@ -277,26 +291,26 @@ the response is available. */
 #define SDO_RES_INTERFACE                         1
 #endif

-/**
+/**
 USE_SINGLE_PDO_MAPPING_ENTRY_DESCR: If this setting is set a PDO mapping entry description just need to be defined for the first entry. For all furher entries the same description is used. */
 #ifndef USE_SINGLE_PDO_MAPPING_ENTRY_DESCR
 #define USE_SINGLE_PDO_MAPPING_ENTRY_DESCR        0
 #endif

-/**
+/**
 BACKUP_PARAMETER_SUPPORTED: If this switch is set, then the functions in the application example to load and<br>
 store backup parameter will be compiled. Furthermore, COE_SUPPORTED shall be set. */
 #ifndef BACKUP_PARAMETER_SUPPORTED
 #define BACKUP_PARAMETER_SUPPORTED                0
 #endif

-/**
+/**
 STORE_BACKUP_PARAMETER_IMMEDIATELY: Objet values will be stored when they are written.This switch is only evaluated if "BACKUP_PARAMETER_SUPPORTED" is set. */
 #ifndef STORE_BACKUP_PARAMETER_IMMEDIATELY
 #define STORE_BACKUP_PARAMETER_IMMEDIATELY        0
 #endif

-/**
+/**
 DIAGNOSIS_SUPPORTED: If this define is set the slave stack supports diagnosis messages (Object 0x10F3). <br>
 To support diagnosis messages COE_SUPPORTED shall be enabled and the platform shall support dynamic memory allocation.<br>
 NOTE: this feature is implemented according to ETG.1020 */
@@ -304,13 +318,13 @@ NOTE: this feature is implemented according to ETG.1020 */
 #define DIAGNOSIS_SUPPORTED                       0
 #endif

-/**
+/**
 EMERGENCY_SUPPORTED: If this define is set the slave stack supports emergency messages. COE_SUPPORTED or SOE_SUPPORTED shall be enabled */
 #ifndef EMERGENCY_SUPPORTED
-#define EMERGENCY_SUPPORTED                       0
+#define EMERGENCY_SUPPORTED                       1
 #endif

-/**
+/**
 VOE_SUPPORTED: If the VoE services should be supported, then this switch shall be set. This means only the calling of the <br>
 VoE functions in mailbox.c are implemented, but the VoE service functions have to be added. Furthermore, the example code cannot be linked<br>
 correctly, because these functions are missing. */
@@ -318,33 +332,33 @@ correctly, because these functions are missing. */
 #define VOE_SUPPORTED                             0
 #endif

-/**
+/**
 SOE_SUPPORTED: If the SoE services should be supported, then this switch shall be set. This means only the calling of the <br>
 SoE functions in mailbox.c are implemented, but the SoE service functions have to be added. Furthermore, the example code cannot be linked<br>
 correctly, because these functions are missing. */
 #ifndef SOE_SUPPORTED
-#define SOE_SUPPORTED                             0
+#define SOE_SUPPORTED                             1
 #endif

-/**
+/**
 EOE_SUPPORTED: If the EoE services should be supported, then this switch shall be set. */
 #ifndef EOE_SUPPORTED
-#define EOE_SUPPORTED                             0
+#define EOE_SUPPORTED                             1
 #endif

-/**
+/**
 STATIC_ETHERNET_BUFFER: If this switch is set a static buffer is used to store ethernet frames, otherwise the buffer is allocated on demand */
 #ifndef STATIC_ETHERNET_BUFFER
 #define STATIC_ETHERNET_BUFFER                    0
 #endif

-/**
+/**
 FOE_SUPPORTED: If the FoE services should be supported, then this switch shall be set.  */
 #ifndef FOE_SUPPORTED
-#define FOE_SUPPORTED                             0
+#define FOE_SUPPORTED                             1
 #endif

-/**
+/**
 MAILBOX_SUPPORTED: This switch is set automatically if at least one mailbox protocol is enabled. */
 #ifndef MAILBOX_SUPPORTED
 #if !COE_SUPPORTED && !AOE_SUPPORTED && !EOE_SUPPORTED && !FOE_SUPPORTED && !SOE_SUPPORTED && !VOE_SUPPORTED
@@ -354,59 +368,59 @@ MAILBOX_SUPPORTED: This switch is set automatically if at least one mailbox prot
 #endif
 #endif

-/**
+/**
 BOOTSTRAPMODE_SUPPORTED: If the firmware update over FoE services should be supported, then this switch shall be set.<br>
 If this switch is set, then also "FOE_SUPPORTED" shall be set.  */
 #ifndef BOOTSTRAPMODE_SUPPORTED
-#define BOOTSTRAPMODE_SUPPORTED                   0
+#define BOOTSTRAPMODE_SUPPORTED                   1
 #endif

-/**
+/**
 OP_PD_REQUIRED: If this switch is reset the state transition SAFEOP_2_OP will also successful if no process data was received. The watchdog will only be active when first process data was received (bEcatFirstOutputsReceived) */
 #ifndef OP_PD_REQUIRED
 #define OP_PD_REQUIRED                            1
 #endif

-/**
+/**
 PREOPTIMEOUT: Specify timeout value in ms for the state transition from Init to PreOP/Boot.(ESI Value : "PreopTimeout").<br>
 NOTE: Within the stack this value - 50ms will be used to react before the master run into the timeout. */
 #ifndef PREOPTIMEOUT
 #define PREOPTIMEOUT                              0x7D0
 #endif

-/**
+/**
 SAFEOP2OPTIMEOUT: Specifiy the timeout in ms from SafeOP to OP. (ESI Value : "SafeopOpTimeout")<br>
 NOTE: Within the stack this value - 50ms will be used to react before the master run into the timeout. */
 #ifndef SAFEOP2OPTIMEOUT
 #define SAFEOP2OPTIMEOUT                          0x2328
 #endif

-/**
+/**
 CHECK_SM_PARAM_ALIGNMENT: If true the SyncManager length and start address will be checked according the ESC Access.<br>
 e.g. ESC_32BIT_ACCESS is set the length and address shall be to an even 4Byte address. */
 #ifndef CHECK_SM_PARAM_ALIGNMENT
 #define CHECK_SM_PARAM_ALIGNMENT                  0
 #endif

-/**
+/**
 EXPLICIT_DEVICE_ID: If this switch is set Explicit device ID requests are handled. For further information about Explicit Device ID see ETG.1020 specification: www.ethercat.org/MemberArea/download_protocolenhancements.asp */
 #ifndef EXPLICIT_DEVICE_ID
 #define EXPLICIT_DEVICE_ID                        0
 #endif

-/**
+/**
 ESC_SM_WD_SUPPORTED: This switch should be set if the SyncManger watchdog provided by the ESC should be used. If reset the process data watchdog is triggered by a local timer */
 #ifndef ESC_SM_WD_SUPPORTED
 #define ESC_SM_WD_SUPPORTED                       1
 #endif

-/**
+/**
 STATIC_OBJECT_DIC: If this switch is set, the object dictionary is "build" static (by default only PIC18 objects are added static) */
 #ifndef STATIC_OBJECT_DIC
 #define STATIC_OBJECT_DIC                         0
 #endif

-/**
+/**
 ESC_EEPROM_ACCESS_SUPPORT: If this switch is set the slave stack provides functions to access the EEPROM. */
 #ifndef ESC_EEPROM_ACCESS_SUPPORT
 #define ESC_EEPROM_ACCESS_SUPPORT                 0
@@ -414,354 +428,354 @@ ESC_EEPROM_ACCESS_SUPPORT: If this switch is set the slave stack provides functi


 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	Compiler Defines
-------
+------
 -----------------------------------------------------------------------------------------*/

-/**
+/**
 FALSE: Will be used for variables from type BOOL */
 #ifndef FALSE
 #define FALSE                                     0
 #endif

-/**
+/**
 TRUE: Will be used for variables from type BOOL  */
 #ifndef TRUE
 #define TRUE                                      1
 #endif

-/**
+/**
 BOOL: Should be adapted to the boolean type of the microcontroller */
 #ifndef BOOL
-#define BOOL                                      unsigned char
+#define BOOL                                      uint8_t
 #endif

-/**
+/**
 UINT8: Should be adapted to the unsigned8 type of the microcontroller  */
 #ifndef UINT8
-#define UINT8                                     unsigned char
+#define UINT8                                     uint8_t
 #endif

-/**
+/**
 UINT16: Should be adapted to the unsigned16 type of the microcontroller  */
 #ifndef UINT16
-#define UINT16                                    unsigned short
+#define UINT16                                    uint16_t
 #endif

-/**
+/**
 UINT32: Should be adapted to the unsigned32 type of the microcontroller  */
 #ifndef UINT32
-#define UINT32                                    unsigned long
+#define UINT32                                    uint32_t
 #endif

-/**
+/**
 UINT64: Should be adapted to the unsigned64 type of the microcontroller  */
 #ifndef UINT64
 #define UINT64                                    unsigned long long
 #endif

-/**
+/**
 USHORT: Should be adapted to the unsigned16 type of the microcontroller */
 #ifndef USHORT
-#define USHORT                                    unsigned short
+#define USHORT                                    uint16_t
 #endif

-/**
+/**
 INT8: Should be adapted to the integer8 type of the microcontroller */
 #ifndef INT8
-#define INT8                                      char
+#define INT8                                      int8_t
 #endif

-/**
+/**
 INT16: Should be adapted to the integer16 type of the microcontroller  */
 #ifndef INT16
-#define INT16                                     short
+#define INT16                                     int16_t
 #endif

-/**
+/**
 INT32: Should be adapted to the integer32 type of the microcontroller */
 #ifndef INT32
-#define INT32                                     long
+#define INT32                                     int32_t
 #endif

-/**
+/**
 INT64: Should be adapted to the integer64 type of the microcontroller */
 #ifndef INT64
 #define INT64                                     long long
 #endif

-/**
+/**
 CHAR: Should be adapted to the character type of the microcontroller */
 #ifndef CHAR
-#define CHAR                                      char
+#define CHAR                                      int8_t
 #endif

-/**
+/**
 UCHAR: Should be adapted to the unsigned character type of the microcontroller */
 #ifndef UCHAR
-#define UCHAR                                     unsigned char
+#define UCHAR                                     uint8_t
 #endif

-/**
+/**
 REAL32: Should be adapted to the 32bit real type of the microcontroller */
 #ifndef REAL32
 #define REAL32                                    float
 #endif

-/**
+/**
 REAL64: Should be adapted to the 64bit real type of the microcontroller */
 #ifndef REAL64
 #define REAL64                                    long double
 #endif

-/**
+/**
 SIZEOF(x): Used to calculate the size in Bytes */
 #ifndef SIZEOF
 #define SIZEOF(x)                                 sizeof(x)
 #endif

-/**
+/**
 HUGE: Should be adapted to the huge type of the microcontroller, if the microcontroller<br>
 does not support a huge type, HUGE shall be defined to nothing */
 #ifndef HUGE
-#define HUGE
+#define HUGE
 #endif

-/**
+/**
 HMEMSET: Should be defined to the memset function for huge memory, if the microcontroller<br>
 does not support a huge type, HMEMSET shall be defined to a 'normal' memset function */
 #ifndef HMEMSET
 #define HMEMSET                                   memset
 #endif

-/**
+/**
 HMEMCPY: Should be defined to the memcpy function for huge memory, if the microcontroller<br>
 does not support a huge type, HMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef HMEMCPY
 #define HMEMCPY                                   memcpy
 #endif

-/**
+/**
 HMEMCMP: Should be defined to the memcmp function for huge memory, if the microcontroller<br>
 does not support a huge type, HMEMCMP shall be defined to a 'normal' memcmp function */
 #ifndef HMEMCMP
 #define HMEMCMP                                   memcmp
 #endif

-/**
+/**
 ESCMEM: Should be defined to select the memory type of the ESC memory (e.g. near, far or huge), if the microcontroller<br>
 does not support different memory types, ESCMEM shall be defined to nothing */
 #ifndef ESCMEM
-#define ESCMEM
+#define ESCMEM
 #endif

-/**
+/**
 ESCMEMCPY: Should be defined to the memcpy function for ESCMEM memory, if the microcontroller<br>
 does not support different memory types, ESCMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef ESCMEMCPY
 #define ESCMEMCPY                                 memcpy
 #endif

-/**
+/**
 ESCMEMSET: Should be defined to the memset function for ESCMEM memory, if the microcontroller<br>
 does not support different memory types, ESCMEMSET shall be defined to a 'normal' memset function */
 #ifndef ESCMEMSET
 #define ESCMEMSET                                 memset
 #endif

-/**
+/**
 ESCMBXMEMCPY: Should be defined to the memcpy function for copying ESCMEM memory to or from MBXMEM memory, if the microcontroller<br>
 does not support different memory types, ESCMBXMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef ESCMBXMEMCPY
 #define ESCMBXMEMCPY                              memcpy
 #endif

-/**
+/**
 MBXMEM: Should be defined to select the memory type of the memory used for mailbox communication (e.g. near, far or huge), <br>
 if the microcontroller does not support different memory types, MBXMEM shall be defined to nothing */
 #ifndef MBXMEM
-#define MBXMEM
+#define MBXMEM
 #endif

-/**
+/**
 MBXMEMCPY: Should be defined to the memcpy function for MBXMEM memory, if the microcontroller<br>
 does not support different memory types, MBXMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef MBXMEMCPY
 #define MBXMEMCPY                                 memcpy
 #endif

-/**
+/**
 MBXMEMCMP: Should be defined to the memcmp function for MBXMEM memory, if the microcontroller<br>
 does not support different memory types, MBXMEMCMP shall be defined to a 'normal' memcmp function */
 #ifndef MBXMEMCMP
 #define MBXMEMCMP                                 memcmp
 #endif

-/**
+/**
 MBXMEMSET: Should be defined to the memcpy function for MBXMEM memory, if the microcontroller<br>
 does not support different memory types, MBXMEMSET shall be defined to a 'normal' memset function */
 #ifndef MBXMEMSET
 #define MBXMEMSET                                 memset
 #endif

-/**
+/**
 MBXSTRLEN: Should be defined to the strlen function for MBXMEM memory, if the microcontroller<br>
 does not support different memory types, MBXSTRLEN shall be defined to a 'normal' strlen function */
 #ifndef MBXSTRLEN
 #define MBXSTRLEN                                 strlen
 #endif

-/**
+/**
 MBXSTRCPY: Should be defined to the strcpy function for MBXMEM memory, if the microcontroller<br>
 does not support different memory types, MBXSTRCPY shall be defined to a 'normal' strcpy function */
 #ifndef MBXSTRCPY
 #define MBXSTRCPY                                 memcpy
 #endif

-/**
+/**
 OBJCONST: Should be used to define the object dictionary in ROM (f.e. define OBJCONST const) or<br>
 in RAM (e.g. define OBJCONST) */
 #ifndef OBJCONST
 #define OBJCONST                                  const
 #endif

-/**
+/**
 VARCONST: Should be used to define the constant variables in ROM (f.e. define VARCONST const) or<br>
 in RAM (e.g. define VARCONST) */
 #ifndef VARCONST
-#define VARCONST
+#define VARCONST
 #endif

-/**
+/**
 VARVOLATILE: Should be used to prevent dummy variables to be deleted due to compiler optimization.  */
 #ifndef VARVOLATILE
 #define VARVOLATILE                               volatile
 #endif

-/**
+/**
 OBJMEM: Should be defined to select the memory type of the memory used for the object dictionary (e.g. near, far or huge), <br>
 if the microcontroller does not support different memory types, OBJMEM shall be defined to nothing */
 #ifndef OBJMEM
-#define OBJMEM
+#define OBJMEM
 #endif

-/**
+/**
 OBJTOMBXMEMCPY: Should be defined to the memcpy function for copying OBJMEM memory to MBXMEM memory, if the microcontroller<br>
 does not support different memory types, OBJTOMBXMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef OBJTOMBXMEMCPY
 #define OBJTOMBXMEMCPY                            memcpy
 #endif

-/**
+/**
 OBJTOMBXSTRCPY: Should be defined to the strcpy function for copying OBJMEM memory to MBXMEM memory, if the microcontroller<br>
 does not support different memory types, OBJTOMBXSTRCPY shall be defined to a 'normal' memcpy function */
 #ifndef OBJTOMBXSTRCPY
 #define OBJTOMBXSTRCPY                            memcpy
 #endif

-/**
+/**
 MBXTOOBJSTRCPY: Should be defined to the strcpy function for copying MBXMEM memory to OBJMEM memory, if the microcontroller<br>
 does not support different memory types, MBXTOOBJSTRCPY shall be defined to a 'normal' memcpy function */
 #ifndef MBXTOOBJSTRCPY
 #define MBXTOOBJSTRCPY                            memcpy
 #endif

-/**
+/**
 OBJMEMCPY: Should be defined to the memcpy function for OBJMEM memory, if the microcontroller<br>
 does not support different memory types, OBJMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef OBJMEMCPY
 #define OBJMEMCPY                                 memcpy
 #endif

-/**
+/**
 OBJSTRLEN: Should be defined to the strlen function for OBJMEM memory, if the microcontroller<br>
 does not support different memory types, OBJSTRLEN shall be defined to a 'normal' strlen function */
 #ifndef OBJSTRLEN
 #define OBJSTRLEN                                 strlen
 #endif

-/**
+/**
 OBJSTRCPY: Should be defined to the strcpy function for OBJMEM memory, if the microcontroller<br>
 does not support different memory types, OBJSTRCPY shall be defined to a 'normal' strcpy function */
 #ifndef OBJSTRCPY
 #define OBJSTRCPY                                 memcpy
 #endif

-/**
+/**
 MAKE_HUGE_PTR: Should be defined to the initialize a pointer variable with an absolute address */
 #ifndef MAKE_HUGE_PTR
 #if !_PIC24
 #define MAKE_HUGE_PTR                             _mkhp
 #else
-#define MAKE_HUGE_PTR
+#define MAKE_HUGE_PTR
 #endif
 #endif

-/**
+/**
 MAKE_PTR_TO_ESC: Should be defined to the initialize the pointer to the ESC */
 #ifndef MAKE_PTR_TO_ESC
 #if MCI_HW && !FC1100_HW
 #define MAKE_PTR_TO_ESC                           &sEsc
 #else
-#define MAKE_PTR_TO_ESC
+#define MAKE_PTR_TO_ESC
 #endif
 #endif

-/**
+/**
 EMCYMEMCPY: Should be defined to the memcpy function for EMCYMEM memory, if the microcontroller<br>
 does not support different memory types, EMCYMEMCPY shall be defined to a 'normal' memcpy function */
 #ifndef EMCYMEMCPY
 #define EMCYMEMCPY                                memcpy
 #endif

-/**
+/**
 EMCYMEMSET: Should be defined to the memset function for EMCYMEM memory, if the microcontroller<br>
 does not support different memory types, EMCYMEMSET shall be defined to a 'normal' memcset function */
 #ifndef EMCYMEMSET
 #define EMCYMEMSET                                memset
 #endif

-/**
+/**
 EMCYMEM: Should be defined to select the memory type of the memory used for the emergencies (e.g. near, far or huge), <br>
 if the microcontroller does not support different memory types, EMCYMEM shall be defined to nothing */
 #ifndef EMCYMEM
-#define EMCYMEM
+#define EMCYMEM
 #endif

-/**
+/**
 MEMCPY: Should be defined to copy data within local memory. */
 #ifndef MEMCPY
 #define MEMCPY                                    memcpy
 #endif

-/**
+/**
 ALLOCMEM(size): Should be defined to the alloc function to get dynamic memory */
 #ifndef ALLOCMEM
 #define ALLOCMEM(size)                            malloc((size))
 #endif

-/**
+/**
 FREEMEM(pointer): Should be defined to the free function to put back dynamic memory */
 #ifndef FREEMEM
 #define FREEMEM(pointer)                          free((pointer))
 #endif

-/**
+/**
 VARMEMSET: Should be defined to the memset function for VARMEM memory, if the microcontroller<br>
 does not support different memory types, EMCYMEMSET shall be defined to a 'normal' memcset function */
 #ifndef VARMEMSET
 #define VARMEMSET                                 memset
 #endif

-/**
+/**
 VARMEM: Should be defined to select the memory type of the memory used for dynamic memory (e.g. near, far or huge), <br>
 if the microcontroller does not support different memory types, VARMEM shall be defined to nothing */
 #ifndef VARMEM
-#define VARMEM
+#define VARMEM
 #endif

-/**
+/**
 MEM_ADDR: Type to access local memory addresses */
 #ifndef MEM_ADDR
 #if CONTROLLER_32BIT
@@ -773,7 +787,7 @@ MEM_ADDR: Type to access local memory addresses */
 #endif
 #endif

-/**
+/**
 GET_MEM_SIZE(ByteSize): Round up the byte size to next matching memory boundary depending on "MEM_ADDR" */
 #ifndef GET_MEM_SIZE
 #if CONTROLLER_32BIT
@@ -785,65 +799,65 @@ GET_MEM_SIZE(ByteSize): Round up the byte size to next matching memory boundary
 #endif
 #endif

-/**
+/**
 APPL_AllocMailboxBuffer(size): Should be defined to a function to get a buffer for a mailbox service,<br>
 this is only used if the switch MAILBOX_QUEUE is set */
 #ifndef APPL_AllocMailboxBuffer
 #if MAILBOX_QUEUE
 #define APPL_AllocMailboxBuffer(size)             malloc((size))
 #else
-#define APPL_AllocMailboxBuffer(size)
+#define APPL_AllocMailboxBuffer(size)
 #endif
 #endif

-/**
+/**
 APPL_FreeMailboxBuffer(pointer): Should be defined to a function to put back a buffer for a mailbox service,<br>
 this is only used if the switch MAILBOX_QUEUE is set */
 #ifndef APPL_FreeMailboxBuffer
 #if MAILBOX_QUEUE
 #define APPL_FreeMailboxBuffer(pointer)           free((pointer))
 #else
-#define APPL_FreeMailboxBuffer(pointer)
+#define APPL_FreeMailboxBuffer(pointer)
 #endif
 #endif

-/**
+/**
 STRUCT_PACKED_START: Is defined before the typedef struct construct to pack the generic structures if necessary */
 #ifndef STRUCT_PACKED_START
-#define STRUCT_PACKED_START
+#define STRUCT_PACKED_START
 #endif

-/**
+/**
 STRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the generic structures if necessary */
 #ifndef STRUCT_PACKED_END
-#define STRUCT_PACKED_END
+#define STRUCT_PACKED_END __attribute__((packed))
 #endif

-/**
+/**
 MBX_STRUCT_PACKED_START: Is defined before the typedef struct construct to pack the MAILBOX structures if necessary */
 #ifndef MBX_STRUCT_PACKED_START
-#define MBX_STRUCT_PACKED_START
+#define MBX_STRUCT_PACKED_START
 #endif

-/**
+/**
 MBX_STRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the MAILBOX structures if necessary */
 #ifndef MBX_STRUCT_PACKED_END
-#define MBX_STRUCT_PACKED_END
+#define MBX_STRUCT_PACKED_END __attribute__((packed))
 #endif

-/**
+/**
 OBJ_STRUCT_PACKED_START: Is defined before the typedef struct construct to pack the OBJECT structures if necessary */
 #ifndef OBJ_STRUCT_PACKED_START
-#define OBJ_STRUCT_PACKED_START
+#define OBJ_STRUCT_PACKED_START
 #endif

-/**
+/**
 OBJ_STRUCT_PACKED_END: Is defined after the typedef struct {} construct to pack the OBJECT structures if necessary */
 #ifndef OBJ_STRUCT_PACKED_END
-#define OBJ_STRUCT_PACKED_END
+#define OBJ_STRUCT_PACKED_END __attribute__((packed))
 #endif

-/**
+/**
 OBJ_DWORD_ALIGN: Shall be set if the object structures are not Byte aligned and 32bit entries are implicitly padded to even 32bit memory addresses. */
 #ifndef OBJ_DWORD_ALIGN
 #if CONTROLLER_32BIT
@@ -853,7 +867,7 @@ OBJ_DWORD_ALIGN: Shall be set if the object structures are not Byte aligned and
 #endif
 #endif

-/**
+/**
 OBJ_WORD_ALIGN: Shall be set if the object structures are not Byte aligned and 16bit entries are implicitly padded to even 16bit memory addresses. */
 #ifndef OBJ_WORD_ALIGN
 #if CONTROLLER_16BIT
@@ -863,108 +877,129 @@ OBJ_WORD_ALIGN: Shall be set if the object structures are not Byte aligned and 1
 #endif
 #endif

-/**
+/**
 ENTER_MBX_CRITICAL: Marco which is called when a critical mailbox section is entered */
 #ifndef ENTER_MBX_CRITICAL
-#define ENTER_MBX_CRITICAL
+#define ENTER_MBX_CRITICAL
 #endif

-/**
+/**
 LEAVE_MBX_CRITICAL: Marco which is called when a critical mailbox section is left */
 #ifndef LEAVE_MBX_CRITICAL
-#define LEAVE_MBX_CRITICAL
+#define LEAVE_MBX_CRITICAL
 #endif

-/**
+/**
 ENTER_AOE_CRITICAL: Marco which is called when a critical AoE section is entered */
 #ifndef ENTER_AOE_CRITICAL
-#define ENTER_AOE_CRITICAL
+#define ENTER_AOE_CRITICAL
 #endif

-/**
+/**
 LEAVE_AOE_CRITICAL: Marco which is called when a critical AoE section is left */
 #ifndef LEAVE_AOE_CRITICAL
-#define LEAVE_AOE_CRITICAL
+#define LEAVE_AOE_CRITICAL
 #endif

-/**
+/**
 ENTER_EMCY_CRITICAL: Marco which is called when a critical emergency section is entered */
 #ifndef ENTER_EMCY_CRITICAL
-#define ENTER_EMCY_CRITICAL
+#define ENTER_EMCY_CRITICAL
 #endif

-/**
+/**
 LEAVE_EMCY_CRITICAL: Marco which is called when a critical emergency section is left */
 #ifndef LEAVE_EMCY_CRITICAL
-#define LEAVE_EMCY_CRITICAL
+#define LEAVE_EMCY_CRITICAL
 #endif


 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	Application Specific Defines
-------
+------
 -----------------------------------------------------------------------------------------*/

-/**
+/**
 MAX_DIAG_MSG: Number of diagnosis message ringbuffer */
 #ifndef MAX_DIAG_MSG
 #define MAX_DIAG_MSG                              0x14
 #endif

-/**
+/**
 MAX_EMERGENCIES: Number of emergencies supported in parallel */
 #ifndef MAX_EMERGENCIES
 #define MAX_EMERGENCIES                           0x1
 #endif

-/**
+/**
 VENDOR_ID: Object 0x1018 SI1 (Vendor ID)	 <br>
 An unique EtherCAT Vendor ID is required. Please find all valid Vendor IDs listed at www.ethercat.org/en/vendor_id_list.html.<br>
 If your company is not listed, please assign an ID for free at www.ethercat.org/memberarea/vendor_id.asp */
-#ifndef VENDOR_ID
+#if SAMPLE_APPLICATION_INTERFACE && TIESC_HW
+#define VENDOR_ID                                 0xE000059D
+#elif TIESC_HW
+#define VENDOR_ID                                 0x0000059D
+#else
 #define VENDOR_ID                                 0xE0000002
 #endif
+//#endif

-/**
+/**
 PRODUCT_CODE: Object 0x1018 SI2 (EtherCAT product code) */
 #ifndef PRODUCT_CODE
-#if FC1100_HW
-#define PRODUCT_CODE                              0x044C0C62
-#elif EL9800_HW
-#define PRODUCT_CODE                              0x26483052
-#else
-#define PRODUCT_CODE                              0x00000000
-#endif
-#endif
-
-/**
+ #if FC1100_HW
+  #define PRODUCT_CODE                              0x044C0C62
+ #elif EL9800_HW
+  #define PRODUCT_CODE                              0x26483052
+ #elif TIESC_HW
+  #if defined (TIESC_SPI_MASTER_MODE)
+   #define PRODUCT_CODE                              0x54490081
+  #elif defined (SOC_K2G) || (SOC_AM65XX)
+   #define PRODUCT_CODE                              0x54490004
+  #elif defined (SOC_AM574x) || defined (SOC_AM572x) || defined (SOC_AM571x)
+   #define PRODUCT_CODE                              0x54490003
+  #elif defined (AM43XX_FAMILY_BUILD)
+   #define PRODUCT_CODE                              0x54490002
+  #else
+   #define PRODUCT_CODE                              0x54490001
+  #endif
+ #else
+  #define PRODUCT_CODE                              0x00000000
+ #endif
+#endif
+
+/**
 REVISION_NUMBER: Object 0x1018 SI3 (EtherCAT product revision number) */
 #ifndef REVISION_NUMBER
-#if CiA402_DEVICE
-#define REVISION_NUMBER                           0x00030211
-#elif EL9800_APPLICATION && _PIC18
-#define REVISION_NUMBER                           0x00010101
-#elif EL9800_APPLICATION && _PIC24
-#define REVISION_NUMBER                           0x00030111
-#elif FC1100_HW
-#define REVISION_NUMBER                           0x00030300
-#elif MCI_HW
-#define REVISION_NUMBER                           0x00010082
-#elif TEST_APPLICATION  && EL9800_HW
-#define REVISION_NUMBER                           0x00010411
-#else
-#define REVISION_NUMBER                           0x00010000
-#endif
-#endif
-
-/**
+ #if CiA402_DEVICE
+  #define REVISION_NUMBER                           0x00030211
+ #elif EL9800_APPLICATION && _PIC18
+  #define REVISION_NUMBER                           0x00010101
+ #elif EL9800_APPLICATION && _PIC24
+  #define REVISION_NUMBER                           0x00030111
+ #elif FC1100_HW
+  #define REVISION_NUMBER                           0x00030300
+ #elif MCI_HW
+  #define REVISION_NUMBER                           0x00010082
+ #elif TEST_APPLICATION  && EL9800_HW
+  #define REVISION_NUMBER                           0x00010411
+ #elif SAMPLE_APPLICATION_INTERFACE && TIESC_HW
+  #define REVISION_NUMBER                           0x00000001
+ #elif TIESC_APPLICATION
+  #define REVISION_NUMBER                           0x00000011
+ #else
+  #define REVISION_NUMBER                           0x00010000
+ #endif
+#endif
+
+/**
 SERIAL_NUMBER: Object 0x1018 SI4 (EtherCAT product serial number) */
 #ifndef SERIAL_NUMBER
 #define SERIAL_NUMBER                             0x00000000
 #endif

-/**
+/**
 DEVICE_PROFILE_TYPE: Slave device type (Object 0x1000)  */
 #ifndef DEVICE_PROFILE_TYPE
 #if CiA402_DEVICE
@@ -974,152 +1009,153 @@ DEVICE_PROFILE_TYPE: Slave device type (Object 0x1000)  */
 #endif
 #endif

-/**
+/**
 DEVICE_NAME: Name of the slave device (Object 0x1008) */
 #ifndef DEVICE_NAME
 #define DEVICE_NAME                               "SSC-Device"
 #endif

-/**
+/**
 DEVICE_NAME_LEN: Length of 'DEVICE_NAME' without '\0' */
 #ifndef DEVICE_NAME_LEN
 #define DEVICE_NAME_LEN                           0xA
 #endif

-/**
+/**
 DEVICE_HW_VERSION: Hardware version of the slave device (Object 0x1009) */
 #ifndef DEVICE_HW_VERSION
 #define DEVICE_HW_VERSION                         "n.a."
 #endif

-/**
+/**
 DEVICE_HW_VERSION_LEN: Length of 'DEVICE_HW_VERSION' without '\0' */
 #ifndef DEVICE_HW_VERSION_LEN
 #define DEVICE_HW_VERSION_LEN                     0x4
 #endif

-/**
+/**
 DEVICE_SW_VERSION: Software version of the slave device (Object 0x100A) */
 #ifndef DEVICE_SW_VERSION
 #define DEVICE_SW_VERSION                         "5.12"
 #endif

-/**
+/**
 DEVICE_SW_VERSION_LEN: Length of 'DEVICE_SW_VERSION' without '\0' */
 #ifndef DEVICE_SW_VERSION_LEN
 #define DEVICE_SW_VERSION_LEN                     0x4
 #endif

-/**
+/**
 MIN_PD_WRITE_ADDRESS: Minimum address for the process output data (Sync Manager 2)<br>
 inside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MIN_PD_WRITE_ADDRESS
 #define MIN_PD_WRITE_ADDRESS                      0x1000
 #endif

-/**
+/**
 MAX_PD_WRITE_ADDRESS: Maximum address for the process output data (Sync Manager 2)<br>
 inside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MAX_PD_WRITE_ADDRESS
 #define MAX_PD_WRITE_ADDRESS                      0x2FFF
 #endif

-/**
+/**
 MIN_PD_READ_ADDRESS: Minimum address for the process input data (Sync Manager 3)<br>
 inside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MIN_PD_READ_ADDRESS
 #define MIN_PD_READ_ADDRESS                       0x1000
 #endif

-/**
+/**
 MAX_PD_READ_ADDRESS: Maximum address for the process input data (Sync Manager 3)<br>
 inside the application memory of the EtherCAT Slave Controller which could be set by the master. The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MAX_PD_READ_ADDRESS
 #define MAX_PD_READ_ADDRESS                       0x2FFF
 #endif

-/**
+/**
 MIN_MBX_SIZE: Minimum mailbox size (Sync Manager 0 and 1) which could be set by the master. The SSC don't support fragmented SDO info object/entry service => at least entry info including 12byte name shall fit in the mailbox buffer */
 #ifndef MIN_MBX_SIZE
 #define MIN_MBX_SIZE                              0x0024
 #endif

-/**
+/**
 MAX_MBX_SIZE: Maximum mailbox size (Sync Manager 0 and 1) which could be set by the master. */
 #ifndef MAX_MBX_SIZE
-#define MAX_MBX_SIZE                              0x0080
+/* increment from 0x80, since KB stack requires 0x100 MBX size, maybe this has to be overridden dynamically */
+#define MAX_MBX_SIZE                              0x0100
 #endif

-/**
+/**
 MIN_MBX_WRITE_ADDRESS: Minimum address for the write (receive) mailbox (Sync Manager 0). The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MIN_MBX_WRITE_ADDRESS
 #define MIN_MBX_WRITE_ADDRESS                     0x1000
 #endif

-/**
+/**
 MAX_MBX_WRITE_ADDRESS: Maximum address for the write (receive) mailbox (Sync Manager 0). The setting have to be within the ranges of the user memory of the ESC (this is not checked by the tool). */
 #ifndef MAX_MBX_WRITE_ADDRESS
 #define MAX_MBX_WRITE_ADDRESS                     0x2FFF
 #endif

-/**
+/**
 MAX_PD_INPUT_SIZE: Maximum size of the process input data (Sync Manager 3) for cyclic exchange. */
 #ifndef MAX_PD_INPUT_SIZE
-#define MAX_PD_INPUT_SIZE                         0x0044
+#define MAX_PD_INPUT_SIZE                         1024
 #endif

-/**
+/**
 MIN_MBX_READ_ADDRESS: Minimum address for the read (send) mailbox (Sync Manager 1). */
 #ifndef MIN_MBX_READ_ADDRESS
 #define MIN_MBX_READ_ADDRESS                      0x1000
 #endif

-/**
+/**
 MAX_MBX_READ_ADDRESS: Maximum address for the read (send) mailbox (Sync Manager 1). */
 #ifndef MAX_MBX_READ_ADDRESS
 #define MAX_MBX_READ_ADDRESS                      0x2FFF
 #endif

-/**
+/**
 MAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for cyclic exchange. */
 #ifndef MAX_PD_OUTPUT_SIZE
-#define MAX_PD_OUTPUT_SIZE                        0x044
+#define MAX_PD_OUTPUT_SIZE                        1024
 #endif

-/**
+/**
 MIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
 In case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
 #ifndef MIN_PD_CYCLE_TIME
-#define MIN_PD_CYCLE_TIME                         0x7A120
+#define MIN_PD_CYCLE_TIME                         0x79E0// 31.2us 0x7A120
 #endif

-/**
+/**
 MAX_PD_CYCLE_TIME: Maximum cycle time in ns the slave is supporting */
 #ifndef MAX_PD_CYCLE_TIME
 #define MAX_PD_CYCLE_TIME                         0xC3500000
 #endif

-/**
+/**
 PD_OUTPUT_DELAY_TIME: Minimum output delay time in ns the slave is supporting (entry 0x1C32:09) */
 #ifndef PD_OUTPUT_DELAY_TIME
 #define PD_OUTPUT_DELAY_TIME                      0x0
 #endif

-/**
+/**
 PD_OUTPUT_CALC_AND_COPY_TIME: Output calc+copy time in ns the slave is supporting (entry 0x1C32:06)<br>
 In case that the value is set to 0 the value of 0x1C32:6 is calculated if 0x1C3x.8 is 1 */
 #ifndef PD_OUTPUT_CALC_AND_COPY_TIME
 #define PD_OUTPUT_CALC_AND_COPY_TIME              0x0
 #endif

-/**
+/**
 PD_INPUT_CALC_AND_COPY_TIME: Input calc+copy time in ns the slave is supporting (entry 0x1C33:06)<br>
 In case that the value is set to 0 the value of 0x1C33:6 is calculated if 0x1C3x.8 is 1 */
 #ifndef PD_INPUT_CALC_AND_COPY_TIME
 #define PD_INPUT_CALC_AND_COPY_TIME               0x0
 #endif

-/**
+/**
 PD_INPUT_DELAY_TIME: Input delay time in ns the slave is supporting (entry 0x1C33:09) */
 #ifndef PD_INPUT_DELAY_TIME
 #define PD_INPUT_DELAY_TIME                       0x0
@@ -1128,9 +1164,9 @@ PD_INPUT_DELAY_TIME: Input delay time in ns the slave is supporting (entry 0x1C3


 /*-----------------------------------------------------------------------------------------
-------
+------
 ------	Test Configuration Defines
-------
+------
 -----------------------------------------------------------------------------------------*/

 #if EL9800_HW && !_PIC24 && !_PIC18
@@ -1202,7 +1238,7 @@ PD_INPUT_DELAY_TIME: Input delay time in ns the slave is supporting (entry 0x1C3
 #endif

 #if BOOTSTRAPMODE_SUPPORTED && !FOE_SUPPORTED
-#error FoE shall be enabled, if Bootstrap state is supported
+#error FoE shall be enabled, if Bootstrap state is supported
 #endif

 #if AOE_SUPPORTED && !MAILBOX_QUEUE
@@ -1274,7 +1310,7 @@ PD_INPUT_DELAY_TIME: Input delay time in ns the slave is supporting (entry 0x1C3
 #endif

 #if STATIC_OBJECT_DIC && !EL9800_APPLICATION
-#error The static object dictionary is only available for the EL9800_APPLICATION.
+#error The static object dictionary is only available for the EL9800_APPLICATION.
 #endif

 #if ESC_EEPROM_ACCESS_SUPPORT && ESC_EEPROM_EMULATION
diff --git a/SlaveFiles/src/ecatappl.c b/SlaveFiles/src/ecatappl.c
index 66bcf6c..d3b7d54 100644
--- a/SlaveFiles/src/ecatappl.c
+++ b/SlaveFiles/src/ecatappl.c
@@ -157,8 +157,11 @@ V4.00 APPL 6: The main function was split in MainInit and MainLoop
 /*ECATCHANGE_START(V5.12) BOOT1*/
 #include "bootloaderappl.h"
 /*ECATCHANGE_END(V5.12) BOOT1*/
+#elif KUNBUS_STACK_APPLICATION
+#include <ssc_kbStack.h>
 #else
 /*CODE_INSERT_START (APPLICATION_FILE)*/
+#include "tiescappl.h"
 /*CODE_INSERT_END*/
 #endif

@@ -238,11 +241,19 @@ UINT16 u16EepromStoreTimeoutValue; /** <\brief timeout in ms to store the EEPROM


 #if MAX_PD_OUTPUT_SIZE > 0
+#ifdef EDMA_LATENCY_ENHANCEMENT
+UINT16             * volatile aPdOutputData;
+#else
 UINT16             aPdOutputData[(MAX_PD_OUTPUT_SIZE>>1)];
 #endif
+#endif
 #if MAX_PD_INPUT_SIZE > 0
+#ifdef EDMA_LATENCY_ENHANCEMENT
+UINT16           * volatile aPdInputData;
+#else
 UINT16           aPdInputData[(MAX_PD_INPUT_SIZE>>1)];
 #endif
+#endif

 /*variables are declared in ecatslv.c*/
 #if ESC_32BIT_ACCESS
@@ -310,11 +321,11 @@ void PDO_InputMapping(void)



-
+
     APPL_InputMapping((UINT16*)aPdInputData);
     HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );

-
+

 #if COE_SUPPORTED
 #if !_PIC18
@@ -448,12 +459,12 @@ void ECAT_CheckTimer(void)
         EsmTimeoutCounter--;
     }

-#if !ESC_SM_WD_SUPPORTED
+#if !ESC_SM_WD_SUPPORTED
 #if MAX_PD_OUTPUT_SIZE > 0
     /*The SyncManager watchdog is not supported, the local watchdog is used*/
     ECAT_CheckWatchdog();
 #endif	 //#if MAX_PD_OUTPUT_SIZE > 0
-#endif //#if !ESC_SM_WD_SUPPORTED
+#endif //#if !ESC_SM_WD_SUPPORTED

 #if UC_SET_ECAT_LED
     ECAT_SetLedIndication();
@@ -546,13 +557,13 @@ void HandleCycleTimeMeasurement(void)
         }
         /* get next start value */
         u32CycleTimeStartValue = GetSystemTimeDelay(0);
-
+
     }/* No DC sync configured */
 }

 /////////////////////////////////////////////////////////////////////////////////////////
 /**
-\param    u32StartTime  Old system time (0x910:0x913) value
+\param    u32StartTime  Old system time (0x910:0x913) value

 \return   System time delta in ns

@@ -565,7 +576,7 @@ UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
    UINT32 u32CurValue = 0;
    UINT32 u32Delta = 0;

-
+
    HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);

    if (u32CurValue > 0)
@@ -601,209 +612,245 @@ UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
 #endif //#if !_PIC18
 #endif //#if COE_SUPPORTED

-#if AL_EVENT_ENABLED
-#if _PIC18
-/* the pragma interrupt_level is used to tell the compiler that these functions will not
-   be called at the same time from the main function and the interrupt routine */
-#pragma interrupt_level 1
-#endif
+#if AL_EVENT_ENABLED /* preif = 1 */
+ #if _PIC18 /* preif = 2 */
+ /* the pragma interrupt_level is used to tell the compiler that these functions will not
+    be called at the same time from the main function and the interrupt routine */
+ #pragma interrupt_level 1
+ #endif  /* _PIC18 */ /* preif = 1 */
+
 void PDI_Isr(void)
-{
+{ /* fun = 1 */
     if(bEscIntEnabled)
-    {
+    { /* fun = 2 */
         /* get the AL event register */
         UINT16  ALEvent = HW_GetALEventRegister_Isr();
         ALEvent = SWAPWORD(ALEvent);

-#if MAX_PD_OUTPUT_SIZE > 0
+#if MAX_PD_OUTPUT_SIZE > 0 /* preif = 2 */
         if ( ALEvent & PROCESS_OUTPUT_EVENT )
-        {
-#if DC_SUPPORTED
+        { /* fun = 3 */
+#if DC_SUPPORTED /* preif = 3 */
             if(bDcRunning && bDcSyncActive)
-            {
+            { /* fun = 4 */
                 /* Reset SM/Sync0 counter. Will be incremented on every Sync0 event*/
                 u16SmSync0Counter = 0;
-            }
-#if COE_SUPPORTED
+            } /* if(bDcRunning && bDcSyncActive) */ /* fun = 3 */
+#if COE_SUPPORTED /* preif = 4 */
             if(sSyncManOutPar.u16SmEventMissedCounter > 0)
-            {
+            { /* fun = 4 */
                 sSyncManOutPar.u16SmEventMissedCounter--;
-            }
+            } /* if(sSyncManOutPar.u16SmEventMissedCounter > 0) */ /* fun = 3 */

 /*ECATCHANGE_START(V5.12) ECAT5*/
-#if MAX_PD_INPUT_SIZE > 0
+#if MAX_PD_INPUT_SIZE > 0 /* preif = 5 */
             sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
-#endif
+#endif /* preif = 4 */
 /*ECATCHANGE_END(V5.12) ECAT5*/

- #else
+#else /* #if COE_SUPPORTED */ /* preif = 4 */
             if(u16SmEventMissedCounter > 0)
-            {
+            { /* fun = 4 */
                 u16SmEventMissedCounter--;
-            }
-#endif //#else #if COE_SUPPORTED
+            } /* if(u16SmEventMissedCounter > 0) */ /* fun = 3 */
+#endif //#else #if COE_SUPPORTED /* preif = 3 */

-#endif //#if DC_SUPPORTED
+#endif //#if DC_SUPPORTED /* preif = 2 */

         /* Outputs were updated, set flag for watchdog monitoring */
         bEcatFirstOutputsReceived = TRUE;

-#if !ESC_SM_WD_SUPPORTED
+#if !ESC_SM_WD_SUPPORTED /* preif = 3 */
         /* reset watchdog counter */
         EcatWdCounter = 0;
-#endif
+#endif /* !ESC_SM_WD_SUPPORTED */ /* preif = 2 */

         /*
             handle output process data event
         */
         if ( bEcatOutputUpdateRunning )
-        {
+        { /* fun = 4 */
             /* slave is in OP, update the outputs */
             PDO_OutputMapping();
-        }
+        } /* if ( bEcatOutputUpdateRunning ) */ /* fun = 3 */
         else
-        {
+        { /* fun = 4 */
             /* Just acknowledge the process data event in the INIT,PreOP and SafeOP state */
-#if ESC_32BIT_ACCESS
+#if ESC_32BIT_ACCESS /* preif = 3 */
             HW_EscReadDWordIsr(u32dummy,nEscAddrOutputData);
             HW_EscReadDWordIsr(u32dummy,(nEscAddrOutputData+nPdOutputSize-4));
-#elif ESC_16BIT_ACCESS
+#elif ESC_16BIT_ACCESS /* preif = 3 */
             HW_EscReadWordIsr(u16dummy,nEscAddrOutputData);
             HW_EscReadWordIsr(u16dummy,(nEscAddrOutputData+nPdOutputSize-2));
-#else
+#else /* ESC_XBIT_ACCESS */ /* preif = 3 */
             HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
             HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
-#endif
-        }
-        }
-#elif MAX_PD_INPUT_SIZE > 0
+#endif /* #else ESC_XBIT_ACCESS */ /* preif = 2 */
+        } /* !if ( bEcatOutputUpdateRunning ) */ /* fun = 3 */
+        } /* if ( ALEvent & PROCESS_OUTPUT_EVENT ) */ /* fun = 2 */
+#elif MAX_PD_INPUT_SIZE > 0 /* preif = 2 */

         if (ALEvent & PROCESS_INPUT_EVENT)
-        {
-#if DC_SUPPORTED
+        { /* fun = 3 */
+#if DC_SUPPORTED /* preif = 3 */
             if (bDcRunning && bDcSyncActive)
-            {
+            { /* fun = 4 */
                 /* Reset SM/Sync0 counter. Will be incremented on every Sync0 event*/
                 u16SmSync0Counter = 0;
-            }
-#if COE_SUPPORTED
+            } /* if (bDcRunning && bDcSyncActive) */ /* fun = 3 */
+#if COE_SUPPORTED /* preif = 4 */
             if (sSyncManInPar.u16SmEventMissedCounter > 0)
-            {
+            { /* fun = 4 */
                 sSyncManInPar.u16SmEventMissedCounter--;
-            }
-#else
+            } /* if (sSyncManInPar.u16SmEventMissedCounter > 0) */ /* fun = 3 */
+#else /* #if COE_SUPPORTED */ /* preif = 4 */
             if (u16SmEventMissedCounter > 0)
-            {
+            { /* fun = 4 */
                 u16SmEventMissedCounter--;
-            }
-#endif //#else #if COE_SUPPORTED
-#endif //#if DC_SUPPORTED
-        }
-
-#endif //#elif MAX_PD_INPUT_SIZE > 0 #if MAX_PD_OUTPUT_SIZE > 0
+            } /* if (u16SmEventMissedCounter > 0) /* fun = 3 */
+#endif //#else #if COE_SUPPORTED /* preif = 3 */
+#endif //#if DC_SUPPORTED /* preif = 2 */
+        } /* if (ALEvent & PROCESS_INPUT_EVENT) */ /* fun = 2 */
+#endif //#elif MAX_PD_INPUT_SIZE > 0 #if MAX_PD_OUTPUT_SIZE > 0 /* preif = 1 */

         /*
             Call ECAT_Application() in SM Sync mode
         */
-#if COE_SUPPORTED
-#if MAX_PD_OUTPUT_SIZE > 0
+#if COE_SUPPORTED /* preif = 2 */
+ #if MAX_PD_OUTPUT_SIZE > 0 /* preif = 3 */
         if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
-        {
+        { /* fun = 3 */
             /* The Application is synchronized to process data Sync Manager event*/
             ECAT_Application();
-        }
-#elif MAX_PD_INPUT_SIZE > 0
+        } /* if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) */ /* fun = 2 */
+ #elif MAX_PD_INPUT_SIZE > 0 /* preif = 3 */
         if(sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
-        {
+        { /* fun = 3 */
             /* The Application is synchronized to process data Sync Manager event*/
             ECAT_Application();
-        }
-#endif
-#else
+        } /* if(sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) */ /* fun = 2 */
+ #endif /* MAX_PD_INPUT_SIZE */ /* preif = 2 */
+#else /* COE_SUPPORTED */ /* preif = 2 */
         if(!bDcSyncActive)
-        {
+        { /* fun = 3 */
             /* The Application is synchronized to process data Sync Manager event*/
             ECAT_Application();
-        }
+        } /* if(!bDcSyncActive) */ /* fun = 2 */

-#endif //#else #if COE_SUPPORTED
+#endif //#else #if COE_SUPPORTED /* preif = 1 */

-#if MAX_PD_INPUT_SIZE > 0
-    if ( bEcatInputUpdateRunning
-#if COE_SUPPORTED
+#if MAX_PD_INPUT_SIZE > 0 /* preif = 2 */
+    if ( bEcatInputUpdateRunning
+#if COE_SUPPORTED /* preif = 3 */
        && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
-#else
+#else /* #if COE_SUPPORTED */ /* preif = 3 */
         && !bDcSyncActive
-#endif
+#endif /* #else #if COE_SUPPORTED */ /* preif = 2 */
         )
-    {
+    { /* fun = 3 */
         /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
         PDO_InputMapping();
-    }
-#endif //#if MAX_PD_INPUT_SIZE > 0
+    } /* if ( bEcatInputUpdateRunning ... */ /* fun = 2 */
+#endif //#if MAX_PD_INPUT_SIZE > 0 /* preif = 1 */

     /*
       Check if cycle exceed
     */
+#if !TIESC_HW /* preif = 2 */
     /*if next SM event was triggered during runtime increment cycle exceed counter*/
     ALEvent = HW_GetALEventRegister_Isr();
     ALEvent = SWAPWORD(ALEvent);

-#if MAX_PD_OUTPUT_SIZE > 0
+#if MAX_PD_OUTPUT_SIZE > 0 /* preif = 3 */
     if ( ALEvent & PROCESS_OUTPUT_EVENT )
-    {
-#if COE_SUPPORTED
+    { /* fun = 3 */
+#if COE_SUPPORTED /* preif = 4 */
         sSyncManOutPar.u16CycleExceededCounter++;
-#if MAX_PD_INPUT_SIZE > 0
+#if MAX_PD_INPUT_SIZE > 0 /* preif = 5 */
         sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
-#endif
-#endif
+#endif /* #if MAX_PD_INPUT_SIZE > 0 */ /* preif = 4 */
+#endif /* #if COE_SUPPORTED */ /* preif = 3 */

       /* Acknowledge the process data event*/
-#if ESC_32BIT_ACCESS
+#if ESC_32BIT_ACCESS /* preif = 4 */
             HW_EscReadDWordIsr(u32dummy,nEscAddrOutputData);
             HW_EscReadDWordIsr(u32dummy,(nEscAddrOutputData+nPdOutputSize-4));
-#elif ESC_16BIT_ACCESS
+#elif ESC_16BIT_ACCESS /* preif = 4 */
             HW_EscReadWordIsr(u16dummy,nEscAddrOutputData);
             HW_EscReadWordIsr(u16dummy,(nEscAddrOutputData+nPdOutputSize-2));
-#else
+#else /* #if ESC_XBIT_ACCESS */ /* preif = 4 */
             HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
             HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
-#endif
-    }
-#elif MAX_PD_INPUT_SIZE > 0
+#endif /* #else #if ESC_XBIT_ACCESS */ /* preif = 3 */
+    } /* if ( ALEvent & PROCESS_OUTPUT_EVENT ) */ /* fun = 2 */
+#elif MAX_PD_INPUT_SIZE > 0 /* preif = 3 */
     if ( ALEvent & PROCESS_INPUT_EVENT )
-    {
-#if COE_SUPPORTED
+    { /* fun = 3 */
+#if COE_SUPPORTED /* preif = 4 */
 /*ECATCHANGE_START(V5.12)*/
         sSyncManInPar.u16CycleExceededCounter++;
 /*ECATCHANGE_END(V5.12)*/
-#endif
+#endif /* #if COE_SUPPORTED */ /* preif = 3 */

       /* Acknowledge the process data event*/
-#if ESC_32BIT_ACCESS
+#if ESC_32BIT_ACCESS /* preif = 4 */
         u32dummy = 0;
         HW_EscWriteDWordIsr(u32dummy,nEscAddrInputData);
-#elif ESC_16BIT_ACCESS
+#elif ESC_16BIT_ACCESS /* preif = 4 */
         u16dummy = 0;
         HW_EscWriteWordIsr(u16dummy,nEscAddrInputData);
-#else
+#else /* #if ESC_XBIT_ACCESS */ /* preif = 4 */
         u8dummy = 0;
         HW_EscWriteByteIsr(u8dummy,nEscAddrInputData);
-#endif
-
-    }
-#endif
-    } //if(bEscIntEnabled)
+#endif /* #else #if ESC_XBIT_ACCESS */ /* preif = 3 */
+    } /* if ( ALEvent & PROCESS_INPUT_EVENT ) */ /* fun = 2 */
+#endif /* preif = 2 */
+#else /* #if MAX_PD_OUTPUT_SIZE > 0 */ /* preif = 2 */
+    /* In TI ESC above approach won't work to figure out cycle exceeded scenario as it may take longer
+       to clear AL event IRQ by firmware, so we measure PDI ISR period instead */
+#ifdef SUPPORT_TI_ESC_CYCLE_EXCEEDED_COUNTER /* preif = 3 */
+    static Uint32 curPdiTimeStamp = 0, lastPdiTimeStamp = 0, pdiIsrPeriod;
+    bsp_get_local_sys_time(&curPdiTimeStamp, 0);
+    if (curPdiTimeStamp < lastPdiTimeStamp)
+        pdiIsrPeriod = 0xFFFFFFFF-lastPdiTimeStamp+curPdiTimeStamp;
+    else
+        pdiIsrPeriod =  curPdiTimeStamp - lastPdiTimeStamp;
+    lastPdiTimeStamp = 	curPdiTimeStamp;
+#if MAX_PD_OUTPUT_SIZE > 0 /* preif = 4 */
+    if (pdiIsrPeriod	< sSyncManOutPar.u32MinCycleTime)
+#elif MAX_PD_INPUT_SIZE > 0 /* preif = 4 */
+    if (pdiIsrPeriod	< sSyncManInPar.u32MinCycleTime)
+#endif /* #else MAX_PD_OUTPUT/INPUT */ /* preif = 3 */
+    {	/* fun = 3 */
+#if MAX_PD_OUTPUT_SIZE > 0 /* preif = 4 */
+    if ( ALEvent & PROCESS_OUTPUT_EVENT )
+    { /* fun = 4 */
+#if COE_SUPPORTED /* preif = 5 */
+        sSyncManOutPar.u16CycleExceededCounter++;
+#if MAX_PD_INPUT_SIZE > 0 /* preif = 6 */
+        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
+#endif /* #if MAX_PD_INPUT_SIZE > 0  */ /* preif = 5 */
+#endif /* #if COE_SUPPORTED */ /* preif = 4 */
+    } /* if ( ALEvent & PROCESS_OUTPUT_EVENT ) */ /* fun = 3 */
+#elif MAX_PD_INPUT_SIZE > 0 /* preif = 4 */
+    if ( ALEvent & PROCESS_INPUT_EVENT )
+    { /* fun = 4 */
+        sSyncManInPar.u16CycleExceededCounter++;
+    } /* if ( ALEvent & PROCESS_INPUT_EVENT ) */ /* fun = 3 */
+#endif /* #else MAX_PD_INPUT_SIZE > 0 ... */ /* preif = 3 */
+    } /* if (pdiIsrPeriod	< sSyncManInPar.u32MinCycleTime) */ /* fun = 2 */
+#endif //SUPPORT_TI_ESC_CYCLE_EXCEEDED_COUNTER /* preif = 2 */
+#endif //!TIESC_HW /* preif = 1 */
+    } //if(bEscIntEnabled) /* fun = 1 */

 /*ECATCHANGE_START(V5.12) ECAT5*/
-#if COE_SUPPORTED
+#if COE_SUPPORTED /* preif = 2 */
     COE_UpdateSyncErrorStatus();
-#endif
+#endif /* preif = 1 */
 /*ECATCHANGE_END(V5.12) ECAT5*/

-}
-#endif //#if AL_EVENT_ENABLED
+} /* fun = 0 */
+#endif //#if AL_EVENT_ENABLED /* preif = 0 */

 #if DC_SUPPORTED
 void Sync0_Isr(void)
@@ -870,13 +917,13 @@ void Sync0_Isr(void)
         }
 #endif

-#if MAX_PD_OUTPUT_SIZE || MAX_PD_INPUT_SIZE
+#if MAX_PD_OUTPUT_SIZE || MAX_PD_INPUT_SIZE
         if(u16SmSync0Value > 0)
         {
            /* Check if Sm-Sync sequence is invalid */
            if (u16SmSync0Counter > u16SmSync0Value)
            {
-#if COE_SUPPORTED
+#if COE_SUPPORTED
 #if MAX_PD_OUTPUT_SIZE > 0
               if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
               {
@@ -899,7 +946,7 @@ void Sync0_Isr(void)
 #endif
            } // if (u16SmSync0Counter > u16SmSync0Value)

-
+
            if ((nPdOutputSize == 0) && (nPdInputSize > 0))
            {
               /* Input only with DC, check if the last input data was read*/
@@ -943,7 +990,7 @@ void Sync0_Isr(void)
         ECAT_Application();

 #if MAX_PD_INPUT_SIZE > 0
-        if ( bEcatInputUpdateRunning
+        if ( bEcatInputUpdateRunning
            && (LatchInputSync0Value > 0) && (LatchInputSync0Value == LatchInputSync0Counter) ) /* Inputs shall be latched on a specific Sync0 event */
         {
             /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
@@ -972,7 +1019,7 @@ void Sync1_Isr(void)
     Sync1WdCounter = 0;

 #if MAX_PD_INPUT_SIZE > 0
-        if ( bEcatInputUpdateRunning
+        if ( bEcatInputUpdateRunning
 #if COE_SUPPORTED
             && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
 #endif
@@ -1144,7 +1191,7 @@ void ECAT_SetLedIndication(void)
                                 {
                                     bEtherCATErrorLed = FALSE;
                                 }
-
+
                                 if(ErrorCounter >= (NumFlashes+5))        //toggle time + 5 cycles low
                                 {
                                     ErrorCounter = 0;
@@ -1166,12 +1213,13 @@ void ECAT_SetLedIndication(void)
                 ms = 0;
             }
         }
-    }
+    }

     /* set the EtherCAT-LED */
     HW_SetLed(((UINT8)bEtherCATRunLed),((UINT8)bEtherCATErrorLed));
 }
 #endif
+
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
  \param     pObjectDictionary   Pointer to application specific object dictionary.
@@ -1310,7 +1358,7 @@ pAPPL_EEPROM_Read = NULL;

           u32Cnt++;
        }
-
+
     }


@@ -1359,20 +1407,18 @@ pAPPL_EEPROM_Read = NULL;

 void MainLoop(void)
 {
-
+
     /*return if initialization not finished */
     if(bInitFinished == FALSE)
     {
         return;
     }

-
-
         /* FreeRun-Mode:  bEscIntEnabled = FALSE, bDcSyncActive = FALSE
            Synchron-Mode: bEscIntEnabled = TRUE, bDcSyncActive = FALSE
            DC-Mode:       bEscIntEnabled = TRUE, bDcSyncActive = TRUE */
         if (
-#if MAX_PD_OUTPUT_SIZE > 0
+#if MAX_PD_OUTPUT_SIZE > 0
             (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
 #else
             !bEscIntEnabled                                     /*free run*/
@@ -1932,7 +1978,7 @@ UINT16 ESC_EepromWriteCRC(void)
     UINT16 u16Crc = 0x00FF;
     UINT16 i,j;

-
+
     u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
     if(u16Return == 0)
     {
@@ -1988,12 +2034,11 @@ void EEPROM_CommandHandler(void)
     EEPROMReg = SWAPWORD(EEPROMReg);
 #endif

-    if (EEPROMReg & ESC_EEPROM_BUSY_MASK)
+    if (EEPROMReg & ESC_EEPROM_BUSY_MASK)
     {
         UINT32 cmd = EEPROMReg  & ESC_EEPROM_CMD_MASK;
         UINT32 addr;
-
-
+
         HW_EscReadDWord(addr,ESC_EEPROM_ADDRESS_OFFSET);
         addr = SWAPDWORD(addr);

@@ -2003,6 +2048,8 @@ void EEPROM_CommandHandler(void)
 /*ECATCHANGE_END(V5.12) EEPROM1*/
         switch (cmd) {
         case 0x00: //IDLE
+		//Clear error bits (except the eeprom crc error)
+            EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK & ~ESC_EEPROM_ERROR_CRC);
             break;
         case ESC_EEPROM_CMD_READ_MASK:
         {
@@ -2023,6 +2070,8 @@ void EEPROM_CommandHandler(void)
                  UINT16 *pData = (UINT16 *)pEEPROM;
 /*ECATCHANGE_START(V5.12) EEPROM1*/
                  HW_EscWrite((MEM_ADDR *)&pData[(addr)], ESC_EEPROM_DATA_OFFSET, EepromReadSize);
+				 //Clear error bits (except the eeprom crc error)
+                 EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK & ~ESC_EEPROM_ERROR_CRC);
 /*ECATCHANGE_END(V5.12) EEPROM1*/
               }
               else
@@ -2047,10 +2096,12 @@ void EEPROM_CommandHandler(void)
                  else
                  {

-                    if (addr <= ESC_EEPROM_SIZE && (pEEPROM != NULL))
+                    if (addr <= ESC_EEPROM_SIZE && (pEEPROM != NULL) && (EEPROMReg & 1))
                     {
                        UINT16 *pData = (UINT16 *)pEEPROM;
                        HW_EscRead((MEM_ADDR *)&pData[(addr)], ESC_EEPROM_DATA_OFFSET, EEPROM_WRITE_SIZE);
+					   //Clear error bits
+                       EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK);
                     }
                     else
                     {
@@ -2068,7 +2119,8 @@ void EEPROM_CommandHandler(void)
             break;
         case ESC_EEPROM_CMD_RELOAD_MASK:
 /* ECATCHANGE_START(V5.12) EEPROM2*/
-            if (EepromReadSize == 8)
+            //if (EepromReadSize == 8)
+            if (0) // For TI EtherCAT slaves the below code doesn't work for reload
             {
                 /* "full" EEPROM emulation ( 8Bytes EEPROM data) */
                 do
@@ -2107,7 +2159,7 @@ void EEPROM_CommandHandler(void)
                         }

                         //Clear error bits
-                        EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK);
+                        //EEPROMReg &= ~(ESC_EEPROM_ERROR_MASK);

                         //ack current reload segment
 #if ESC_32BIT_ACCESS
@@ -2116,7 +2168,7 @@ void EEPROM_CommandHandler(void)
 #else
                         UINT16 TmpData = SWAPWORD(EEPROMReg);
                         HW_EscWriteWord(TmpData, ESC_EEPROM_CONTROL_OFFSET);
-#endif
+#endif

                         // read EEPROM control (to check if the reload is still pending)
 #if ESC_32BIT_ACCESS
@@ -2156,7 +2208,6 @@ void EEPROM_CommandHandler(void)
                 }
                 else
                 {
-
                     Result = HW_EepromReload();
                     if (Result != 0 || (pEEPROM == NULL))
                     {
@@ -2194,7 +2245,7 @@ void EEPROM_CommandHandler(void)
 #else
         UINT16 TmpData = SWAPWORD(EEPROMReg);
         HW_EscWriteWord(TmpData,ESC_EEPROM_CONTROL_OFFSET);
-#endif
+#endif
         }
     }
 }
diff --git a/SlaveFiles/src/ecatappl.h b/SlaveFiles/src/ecatappl.h
index d179fcd..9163d1b 100644
--- a/SlaveFiles/src/ecatappl.h
+++ b/SlaveFiles/src/ecatappl.h
@@ -43,11 +43,10 @@ V5.01 : Start file change log
 ------
 -----------------------------------------------------------------------------------------*/

-#include "ecat_def.h"
-
-
 #ifndef _ECATAPPL_H_
-#define _ECATAPPL_H_
+#define _ECATAPPL_H_    1
+
+#include "ecat_def.h"

 /*-----------------------------------------------------------------------------------------
 ------
@@ -56,70 +55,69 @@ V5.01 : Start file change log
 -----------------------------------------------------------------------------------------*/

 #if CONTROLLER_16BIT || CONTROLLER_32BIT
-/*Set to unsigned short to handle bit entries correct*/
-#define     BOOLEAN(x)                 UINT16(x):1 /**< \brief Marco to define BOOLEAN object entry*/
-#define     BIT1(x)                    UINT16(x):1 /**< \brief Marco to define BIT1 object entry*/
-#define     BIT2(x)                    UINT16(x):2 /**< \brief Marco to define BIT2 object entry*/
-#define     BIT3(x)                    UINT16(x):3 /**< \brief Marco to define BIT3 object entry*/
-#define     BIT4(x)                    UINT16(x):4 /**< \brief Marco to define BIT4 object entry*/
-#define     BIT5(x)                    UINT16(x):5 /**< \brief Marco to define BIT5 object entry*/
-#define     BIT6(x)                    UINT16(x):6 /**< \brief Marco to define BIT5 object entry*/
-#define     BIT7(x)                    UINT16(x):7 /**< \brief Marco to define BIT6 object entry*/
-#define     BIT8(x)                    UINT16(x):8 /**< \brief Marco to define BIT7 object entry*/
-#define     ALIGN0(x)
-#define     ALIGN1(x)                  UINT16(x):1; /**< \brief Marco to define ALIGN1 object entry*/
-#define     ALIGN2(x)                  UINT16(x):2; /**< \brief Marco to define ALIGN2 object entry*/
-#define     ALIGN3(x)                  UINT16(x):3; /**< \brief Marco to define ALIGN3 object entry*/
-#define     ALIGN4(x)                  UINT16(x):4; /**< \brief Marco to define ALIGN4 object entry*/
-#define     ALIGN5(x)                  UINT16(x):5; /**< \brief Marco to define ALIGN5 object entry*/
-#define     ALIGN6(x)                  UINT16(x):6; /**< \brief Marco to define ALIGN6 object entry*/
-#define     ALIGN7(x)                  UINT16(x):7; /**< \brief Marco to define ALIGN7 object entry*/
-#define     ALIGN8(x)                  UINT16(x):8; /**< \brief Marco to define ALIGN8 object entry*/
-#define     ALIGN9(x)                  UINT16(x):9; /**< \brief Marco to define ALIGN9 object entry*/
-#define     ALIGN10(x)                 UINT16(x):10; /**< \brief Marco to define ALIGN10 object entry*/
-#define     ALIGN11(x)                 UINT16(x):11; /**< \brief Marco to define ALIGN11 object entry*/
-#define     ALIGN12(x)                 UINT16(x):12; /**< \brief Marco to define ALIGN12 object entry*/
-#define     ALIGN13(x)                 UINT16(x):13; /**< \brief Marco to define ALIGN13 object entry*/
-#define     ALIGN14(x)                 UINT16(x):14; /**< \brief Marco to define ALIGN14 object entry*/
-#define     ALIGN15(x)                 UINT16(x):15; /**< \brief Marco to define ALIGN15 object entry*/
+ /*Set to unsigned short to handle bit entries correct*/
+ #define     BOOLEAN(x)                 UINT16(x):1 /**< \brief Marco to define BOOLEAN object entry*/
+ #define     BIT1(x)                    UINT16(x):1 /**< \brief Marco to define BIT1 object entry*/
+ #define     BIT2(x)                    UINT16(x):2 /**< \brief Marco to define BIT2 object entry*/
+ #define     BIT3(x)                    UINT16(x):3 /**< \brief Marco to define BIT3 object entry*/
+ #define     BIT4(x)                    UINT16(x):4 /**< \brief Marco to define BIT4 object entry*/
+ #define     BIT5(x)                    UINT16(x):5 /**< \brief Marco to define BIT5 object entry*/
+ #define     BIT6(x)                    UINT16(x):6 /**< \brief Marco to define BIT5 object entry*/
+ #define     BIT7(x)                    UINT16(x):7 /**< \brief Marco to define BIT6 object entry*/
+ #define     BIT8(x)                    UINT16(x):8 /**< \brief Marco to define BIT7 object entry*/
+ #define     ALIGN0(x)
+ #define     ALIGN1(x)                  UINT16(x):1; /**< \brief Marco to define ALIGN1 object entry*/
+ #define     ALIGN2(x)                  UINT16(x):2; /**< \brief Marco to define ALIGN2 object entry*/
+ #define     ALIGN3(x)                  UINT16(x):3; /**< \brief Marco to define ALIGN3 object entry*/
+ #define     ALIGN4(x)                  UINT16(x):4; /**< \brief Marco to define ALIGN4 object entry*/
+ #define     ALIGN5(x)                  UINT16(x):5; /**< \brief Marco to define ALIGN5 object entry*/
+ #define     ALIGN6(x)                  UINT16(x):6; /**< \brief Marco to define ALIGN6 object entry*/
+ #define     ALIGN7(x)                  UINT16(x):7; /**< \brief Marco to define ALIGN7 object entry*/
+ #define     ALIGN8(x)                  UINT16(x):8; /**< \brief Marco to define ALIGN8 object entry*/
+ #define     ALIGN9(x)                  UINT16(x):9; /**< \brief Marco to define ALIGN9 object entry*/
+ #define     ALIGN10(x)                 UINT16(x):10; /**< \brief Marco to define ALIGN10 object entry*/
+ #define     ALIGN11(x)                 UINT16(x):11; /**< \brief Marco to define ALIGN11 object entry*/
+ #define     ALIGN12(x)                 UINT16(x):12; /**< \brief Marco to define ALIGN12 object entry*/
+ #define     ALIGN13(x)                 UINT16(x):13; /**< \brief Marco to define ALIGN13 object entry*/
+ #define     ALIGN14(x)                 UINT16(x):14; /**< \brief Marco to define ALIGN14 object entry*/
+ #define     ALIGN15(x)                 UINT16(x):15; /**< \brief Marco to define ALIGN15 object entry*/
 #else
-#define     BOOLEAN(x)                  UINT8(x):1 /**< \brief Marco to define BOOLEAN object entry*/
-#define     BIT1(x)                     UINT8(x):1 /**< \brief Marco to define BIT1 object entry*/
-#define     BIT2(x)                     UINT8(x):2 /**< \brief Marco to define BIT2 object entry*/
-#define     BIT3(x)                     UINT8(x):3 /**< \brief Marco to define BIT3 object entry*/
-#define     BIT4(x)                     UINT8(x):4 /**< \brief Marco to define BIT4 object entry*/
-#define     BIT5(x)                     UINT8(x):5 /**< \brief Marco to define BIT5 object entry*/
-#define     BIT6(x)                     UINT8(x):6 /**< \brief Marco to define BIT5 object entry*/
-#define     BIT7(x)                     UINT8(x):7 /**< \brief Marco to define BIT6 object entry*/
-#define     BIT8(x)                     UINT8(x):8 /**< \brief Marco to define BIT7 object entry*/
-#define     ALIGN0(x)
-#define     ALIGN1(x)                   UINT8(x):1; /**< \brief Marco to define ALIGN1 object entry*/
-#define     ALIGN2(x)                   UINT8(x):2; /**< \brief Marco to define ALIGN2 object entry*/
-#define     ALIGN3(x)                   UINT8(x):3; /**< \brief Marco to define ALIGN3 object entry*/
-#define     ALIGN4(x)                   UINT8(x):4; /**< \brief Marco to define ALIGN4 object entry*/
-#define     ALIGN5(x)                   UINT8(x):5; /**< \brief Marco to define ALIGN5 object entry*/
-#define     ALIGN6(x)                   UINT8(x):6; /**< \brief Marco to define ALIGN6 object entry*/
-#define     ALIGN7(x)                   UINT8(x):7; /**< \brief Marco to define ALIGN7 object entry*/
-#define     ALIGN8(x)                   UINT8(x):8; /**< \brief Marco to define ALIGN8 object entry*/
-#if _PIC18
-#define     ALIGN9(x)                   UINT8 x1:1; UINT8(x):8;
-#define     ALIGN10(x)                  UINT8 x1:2; UINT8(x):8;
-#define     ALIGN11(x)                  UINT8 x1:3; UINT8(x):8;
-#define     ALIGN12(x)                  UINT8 x1:4; UINT8(x):8;
-#define     ALIGN13(x)                  UINT8 x1:5; UINT8(x):8;
-#define     ALIGN14(x)                  UINT8 x1:6; UINT8(x):8;
-#define     ALIGN15(x)                  UINT8 x1:7; UINT8(x):8;
-#else
-#define     ALIGN9(x)                  UINT16(x):9; /**< \brief Marco to define ALIGN9 object entry*/
-#define     ALIGN10(x)                 UINT16(x):10; /**< \brief Marco to define ALIGN10 object entry*/
-#define     ALIGN11(x)                 UINT16(x):11; /**< \brief Marco to define ALIGN11 object entry*/
-#define     ALIGN12(x)                 UINT16(x):12; /**< \brief Marco to define ALIGN12 object entry*/
-#define     ALIGN13(x)                 UINT16(x):13; /**< \brief Marco to define ALIGN13 object entry*/
-#define     ALIGN14(x)                 UINT16(x):14; /**< \brief Marco to define ALIGN14 object entry*/
-#define     ALIGN15(x)                 UINT16(x):15; /**< \brief Marco to define ALIGN15 object entry*/
-#endif
+ #define     BOOLEAN(x)                  UINT8(x):1 /**< \brief Marco to define BOOLEAN object entry*/
+ #define     BIT1(x)                     UINT8(x):1 /**< \brief Marco to define BIT1 object entry*/
+ #define     BIT2(x)                     UINT8(x):2 /**< \brief Marco to define BIT2 object entry*/
+ #define     BIT3(x)                     UINT8(x):3 /**< \brief Marco to define BIT3 object entry*/
+ #define     BIT4(x)                     UINT8(x):4 /**< \brief Marco to define BIT4 object entry*/
+ #define     BIT5(x)                     UINT8(x):5 /**< \brief Marco to define BIT5 object entry*/
+ #define     BIT6(x)                     UINT8(x):6 /**< \brief Marco to define BIT5 object entry*/
+ #define     BIT7(x)                     UINT8(x):7 /**< \brief Marco to define BIT6 object entry*/
+ #define     BIT8(x)                     UINT8(x):8 /**< \brief Marco to define BIT7 object entry*/
+ #define     ALIGN0(x)
+ #define     ALIGN1(x)                   UINT8(x):1; /**< \brief Marco to define ALIGN1 object entry*/
+ #define     ALIGN2(x)                   UINT8(x):2; /**< \brief Marco to define ALIGN2 object entry*/
+ #define     ALIGN3(x)                   UINT8(x):3; /**< \brief Marco to define ALIGN3 object entry*/
+ #define     ALIGN4(x)                   UINT8(x):4; /**< \brief Marco to define ALIGN4 object entry*/
+ #define     ALIGN5(x)                   UINT8(x):5; /**< \brief Marco to define ALIGN5 object entry*/
+ #define     ALIGN6(x)                   UINT8(x):6; /**< \brief Marco to define ALIGN6 object entry*/
+ #define     ALIGN7(x)                   UINT8(x):7; /**< \brief Marco to define ALIGN7 object entry*/
+ #define     ALIGN8(x)                   UINT8(x):8; /**< \brief Marco to define ALIGN8 object entry*/
+ #if _PIC18
+  #define     ALIGN9(x)                   UINT8 x1:1; UINT8(x):8;
+  #define     ALIGN10(x)                  UINT8 x1:2; UINT8(x):8;
+  #define     ALIGN11(x)                  UINT8 x1:3; UINT8(x):8;
+  #define     ALIGN12(x)                  UINT8 x1:4; UINT8(x):8;
+  #define     ALIGN13(x)                  UINT8 x1:5; UINT8(x):8;
+  #define     ALIGN14(x)                  UINT8 x1:6; UINT8(x):8;
+  #define     ALIGN15(x)                  UINT8 x1:7; UINT8(x):8;
+ #else
+  #define     ALIGN9(x)                  UINT16(x):9; /**< \brief Marco to define ALIGN9 object entry*/
+  #define     ALIGN10(x)                 UINT16(x):10; /**< \brief Marco to define ALIGN10 object entry*/
+  #define     ALIGN11(x)                 UINT16(x):11; /**< \brief Marco to define ALIGN11 object entry*/
+  #define     ALIGN12(x)                 UINT16(x):12; /**< \brief Marco to define ALIGN12 object entry*/
+  #define     ALIGN13(x)                 UINT16(x):13; /**< \brief Marco to define ALIGN13 object entry*/
+  #define     ALIGN14(x)                 UINT16(x):14; /**< \brief Marco to define ALIGN14 object entry*/
+  #define     ALIGN15(x)                 UINT16(x):15; /**< \brief Marco to define ALIGN15 object entry*/
+ #endif
 #endif
-#endif //_ECATAPPL_H_

 #if defined(_ECATAPPL_) && (_ECATAPPL_ == 1)
     #define PROTO
@@ -186,7 +184,7 @@ PROTO    UINT16     ESC_EepromWriteCRC(void);
 PROTO   void EEPROM_CommandHandler(void);
 #endif

-
+#endif //_ECATAPPL_H_

 #undef PROTO
 /** @}*/
diff --git a/SlaveFiles/src/ecatslv.c b/SlaveFiles/src/ecatslv.c
index 9a9d92b..da23f83 100644
--- a/SlaveFiles/src/ecatslv.c
+++ b/SlaveFiles/src/ecatslv.c
@@ -234,8 +234,11 @@ V4.00 ECAT 7: The return values for the AL-StatusCode were changed to UINT16
 /*ECATCHANGE_START(V5.12) BOOT1*/
 #include "bootloaderappl.h"
 /*ECATCHANGE_END(V5.12) BOOT1*/
+#elif KUNBUS_STACK_APPLICATION
+#include <ssc_kbStack.h>
 #else
 /*CODE_INSERT_START (APPLICATION_FILE)*/
+#include "tiescappl.h"
 /*CODE_INSERT_END*/
 #endif

@@ -302,7 +305,7 @@ void ResetALEventMask(UINT16 intMask)
 #if ESC_32BIT_ACCESS
     UINT32 u32Mask = 0;
     HW_EscReadDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
-#if BIG_ENDIAN_FORMAT
+#if BIG_ENDIAN_FORMAT
     u32Mask = SWAPDWORD(u32Mask);
 #endif
     u32Mask &= (UINT32)intMask;
@@ -310,7 +313,7 @@ void ResetALEventMask(UINT16 intMask)
 #else
     UINT16 mask;
     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
-
+
 #if BIG_ENDIAN_FORMAT
     mask = SWAPWORD(mask);
 #endif
@@ -348,7 +351,7 @@ void SetALEventMask(UINT16 intMask)
     #if ESC_32BIT_ACCESS
     UINT32 u32Mask = 0;
     HW_EscReadDWord(u32Mask, ESC_AL_EVENTMASK_OFFSET);
-#if BIG_ENDIAN_FORMAT
+#if BIG_ENDIAN_FORMAT
     u32Mask = SWAPDWORD(u32Mask);
 #endif
     u32Mask |= (UINT32)intMask;
@@ -356,7 +359,7 @@ void SetALEventMask(UINT16 intMask)
 #else
     UINT16 mask;
     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
-
+

 #if BIG_ENDIAN_FORMAT
     mask = SWAPWORD(mask);
@@ -447,7 +450,7 @@ TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
 #else
     SyncManInfo.PhysicalStartAddress = SWAPWORD(SyncManInfo.PhysicalStartAddress);
     SyncManInfo.Length = SWAPWORD(SyncManInfo.Length);
-#if ESC_16BIT_ACCESS
+#if ESC_16BIT_ACCESS
     SyncManInfo.Settings[0] = SWAPWORD(SyncManInfo.Settings[0]);
     SyncManInfo.Settings[1] = SWAPWORD(SyncManInfo.Settings[1]);
 #endif
@@ -496,7 +499,7 @@ void DisableSyncManChannel(UINT8 channel)
 #endif

     HW_EscWriteWord(smStatus,Offset);
-
+
     /*wait until SyncManager is disabled*/
     do
     {
@@ -558,7 +561,7 @@ void EnableSyncManChannel(UINT8 channel)
 #endif

     HW_EscWriteWord(smStatus,Offset);
-
+
     /*wait until SyncManager is enabled*/
     do
     {
@@ -573,7 +576,7 @@ void EnableSyncManChannel(UINT8 channel)
     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));

     HW_EscWriteByte(smStatus,Offset);
-
+
     /*wait until SyncManager is enabled*/
     do
     {
@@ -825,9 +828,9 @@ UINT8    CheckSmSettings(UINT8 maxChannel)

         //Check if max address defines are within the available ESC address range
         if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
-            || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
-            || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
-            || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
+         || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
+         || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
+         || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
         {
             /*The defines for maximum SM addresses are invalid for the used ESC (change the defines in the file ecat_def.h or the SSC Tool)
             It may be also required to adapt the SM settings in the ESI file*/
@@ -1342,8 +1345,8 @@ UINT16 StartInputHandler(void)
     u16ALEventMask = 0;


-    /*
-        --- Check if SyncManager areas overlapping ---
+    /*
+        --- Check if SyncManager areas overlapping ---
     */
 #if MAX_PD_OUTPUT_SIZE > 0
     bEcatFirstOutputsReceived = FALSE;
@@ -1385,7 +1388,7 @@ UINT16 StartInputHandler(void)
        the Sync Manager memory areas for the Mailbox */

     if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
-       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
+     || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
         )
     {
 #if DIAGNOSIS_SUPPORTED
@@ -1426,7 +1429,7 @@ UINT16 StartInputHandler(void)
     }
 #endif //#if MAX_PD_OUTPUT_SIZE > 0

-    /*
+    /*
         --- Check configured synchronisation ---
     */

@@ -1515,7 +1518,7 @@ UINT16 StartInputHandler(void)
 #if DIAGNOSIS_SUPPORTED
                 Diag_CreateNewMessage(DIAG_CODE_APPL_SYNC,DIAG_MSG_TYPE_ERROR,DIAG_TEXT_ID_INVALID_REG_981,0,NULL);
 #endif
-                return ALSTATUSCODE_DCINVALIDSYNCCFG;
+                return ALSTATUSCODE_DCINVALIDSYNCCFG;
     }
         }
 #endif //#if COE_SUPPORTED
@@ -1654,7 +1657,7 @@ UINT16 StartInputHandler(void)
             if (nPdOutputSize > 0)
             {
                 SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
-
+
                 if (nPdInputSize > 0)
                 {
                     SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
@@ -1749,7 +1752,7 @@ UINT16 StartInputHandler(void)
 #if MAX_PD_INPUT_SIZE > 0
         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
-#endif
+#endif
 /*ECATCHANGE_END(V5.12) ECAT1*/
     }
 #endif
@@ -1776,7 +1779,7 @@ UINT16 StartInputHandler(void)
         /* Update value for AL Event Mask register (0x204) */
         if(bEscIntEnabled)
         {
-#if MAX_PD_OUTPUT_SIZE > 0
+#if MAX_PD_OUTPUT_SIZE > 0
             if(nPdOutputSize > 0)
             {
                 u16ALEventMask = PROCESS_OUTPUT_EVENT;
@@ -1837,7 +1840,7 @@ UINT16 StartInputHandler(void)
         {

             u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
-
+
             if((cycleTimeSync1 % cycleTimeSync0) == 0)
             {
                 /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
@@ -1860,13 +1863,13 @@ UINT16 StartInputHandler(void)

 #endif //#if MAX_PD_INPUT_SIZE > 0
     }
-    else
+    else
     {
         if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
         {
             /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
             u16SmSync0Value = 1;
-        }
+        }

 #if MAX_PD_INPUT_SIZE > 0
         if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
@@ -2058,7 +2061,7 @@ UINT16 StartInputHandler(void)
     {
         EnableSyncManChannel(PROCESS_DATA_OUT);
     }
-#endif //#if MAX_PD_OUTPUT_SIZE > 0
+#endif //#if MAX_PD_OUTPUT_SIZE > 0

 #if MAX_PD_INPUT_SIZE > 0
     if(nPdInputSize > 0)
@@ -2341,7 +2344,7 @@ void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
     {
         u8EcatErrorLed = LED_SINGLEFLASH;
     }
-    else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
+    else if(alStatusCode == ALSTATUSCODE_SMWATCHDOG)
     {
         u8EcatErrorLed = LED_DOUBLEFLASH;
     }
@@ -2494,13 +2497,13 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
 #if MAX_PD_OUTPUT_SIZE == 0
                 if (nPdOutputSize > 0)
                 {
-                    result = ALSTATUSCODE_INVALIDOUTPUTMAPPING; //output size shall be 0
+                    result = ALSTATUSCODE_INVALIDOUTPUTMAPPING; //output size shall be 0
                 }
 #endif
 #if MAX_PD_INPUT_SIZE == 0
             if (result == 0 && nPdInputSize > 0)
             {
-                result = ALSTATUSCODE_INVALIDOUTPUTMAPPING; //input size shall be 0
+                result = ALSTATUSCODE_INVALIDOUTPUTMAPPING; //input size shall be 0
             }
 #endif
         }
@@ -2552,9 +2555,9 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
                 bApplEsmPending = FALSE;
                 /* additionally there could be an application specific check (in ecatappl.c)
                     if the state transition from INIT to BOOT should be done
-                    if result is NOERROR_INWORK, the slave will stay in INIT until timeout
+                    if result is NOERROR_INWORK, the slave will stay in INIT until timeout
                     or transition is complete by AL_ControlRes*/
-
+
                 result = APPL_StartMailboxHandler();
                 if ( result == 0 )
                 {
@@ -2612,7 +2615,11 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
 #endif

             BackToInitTransition();
-
+#if TIESC_HW
+#ifdef ENABLE_ONLINE_FIRMWARE_UPGRADE
+            bsp_boot_2_init_handler();
+#endif
+#endif


             break;
@@ -2754,7 +2761,7 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
         case SAFEOP_2_PREOP:
             /* stop the input handler (function is defined above) */
             APPL_StopInputHandler();
-
+
             StopInputHandler();

             bApplEsmPending = FALSE;
@@ -2773,13 +2780,13 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
             {
                 break;
             }
-
+
             stateTrans = SAFEOP_2_INIT;

         case SAFEOP_2_INIT:
             /* stop the input handler (function is defined above) */
             result = APPL_StopInputHandler();
-
+
             StopInputHandler();

             bApplEsmPending = FALSE;
@@ -2820,7 +2827,7 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
                         EnableSyncManChannel(PROCESS_DATA_OUT);
                     }
 #if MAX_PD_INPUT_SIZE > 0
-                    else
+                    else
 #endif
 #endif //#if MAX_PD_OUTPUT_SIZE > 0
 #if MAX_PD_INPUT_SIZE > 0
@@ -2831,7 +2838,7 @@ void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
 #endif //#if MAX_PD_INPUT_SIZE > 0
                 }
 /*ECATCHANGE_END(V5.12) ESM2*/
-
+
             result = NOERROR_NOSTATECHANGE;
             break;

@@ -3062,7 +3069,7 @@ void AL_ControlRes(void)
                         }

                     StopInputHandler();
-
+
                     if(bLocalErrorFlag)
                     {
                         /*Set application specified error*/
@@ -3230,11 +3237,11 @@ void AL_ControlRes(void)
 #if OP_PD_REQUIRED
 #if MAX_PD_OUTPUT_SIZE > 0
                             if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
-#endif
+#endif
 #endif
                             {
 /*ECATCHANGE_START(V5.12) ESM4*/
-                                bApplEsmPending = FALSE;
+                                bApplEsmPending = FALSE;
 /*ECATCHANGE_END(V5.12) ESM4*/
                                 result = APPL_StartOutputHandler();

@@ -3253,8 +3260,8 @@ void AL_ControlRes(void)
                                     }
                                 }
                             }
-                        }
-                    }
+                        }
+                    }
                 break;
 #endif //#if !BOOTLOADER_SAMPLE
             }//Switch - transition
@@ -3322,7 +3329,7 @@ void ECAT_CheckWatchdog(void)
     }
 }
 #endif //#if MAX_PD_OUTPUT_SIZE > 0
-#endif //#if !ESC_SM_WD_SUPPORTED
+#endif //#if !ESC_SM_WD_SUPPORTED

 #if DC_SUPPORTED
 /////////////////////////////////////////////////////////////////////////////////////////
@@ -3346,7 +3353,7 @@ void DC_CheckWatchdog(void)
         if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
         {
                 /*Sync0 watchdog expired*/
-                bDcRunning = FALSE;
+                bDcRunning = FALSE;
         }
         else
         {
@@ -3440,7 +3447,7 @@ void CheckIfEcatError(void)
       HW_EscReadDWord(WdStatusOK, ESC_PD_WD_STATE);

       WdStatusOK = SWAPDWORD(WdStatusOK);
-#else
+#else
       UINT16 WdStatusOK = 0;

       HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
@@ -3487,7 +3494,7 @@ void CheckIfEcatError(void)
                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
                return;
            }
-
+
        }
    }
 #endif
@@ -3496,7 +3503,7 @@ void CheckIfEcatError(void)
 /**
  \param    alStatus: requested state
  \param    alStatusCode: value for the AL-Status register
-
+
  \brief    This function changes the state of the EtherCAT slave if the requested state
              is lower than the actual state, otherwise the error condition will be reset.
 *////////////////////////////////////////////////////////////////////////////////////////
@@ -3535,7 +3542,7 @@ void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
                 {
                     case INIT_2_PREOP:
                     case INIT_2_BOOT:
-
+
                           APPL_StopMailboxHandler();
 #if MAILBOX_SUPPORTED
                           MBX_StopMailboxHandler();
@@ -3559,7 +3566,7 @@ void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
             else
             {
                 /*State transition succeed*/
-
+
                 switch(nEcatStateTrans)
                 {
 #if MAILBOX_SUPPORTED
@@ -3606,7 +3613,7 @@ void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
             bLocalErrorFlag = TRUE;
             u16LocalErrorCode = alStatusCode;

-/*ECATCHANGE_START(V5.12) ESM1*/
+/*ECATCHANGE_START(V5.12) ESM1*/
             if (((nAlStatus & STATE_CHANGE) != STATE_CHANGE) || ((alStatus & STATE_MASK) < (nAlStatus & STATE_MASK)))
             {
                 /* Local error has happened, we change the state if necessary */
@@ -3614,7 +3621,7 @@ void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
                /* no error pending and the target state is lower than the current one*/
                 AL_ControlInd(alStatus, alStatusCode);
             }
-/*ECATCHANGE_END(V5.12) ESM1*/
+/*ECATCHANGE_END(V5.12) ESM1*/
         }
         else if (bLocalErrorFlag)
         {
@@ -3816,7 +3823,7 @@ void ECAT_Main(void)
     ALEventReg = SWAPWORD(ALEventReg);

 #if ESC_EEPROM_EMULATION
-    if ((ALEventReg & EEPROM_CMD_PENDING))
+    if ((ALEventReg & EEPROM_CMD_PENDING))
     {
         EEPROM_CommandHandler();
     }
@@ -3848,7 +3855,7 @@ void ECAT_Main(void)
         ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

         AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
-
+
         /* SM-Change-Event was handled too */
     }

diff --git a/SlaveFiles/src/ecatslv.h b/SlaveFiles/src/ecatslv.h
index e821460..bd4c0a4 100644
--- a/SlaveFiles/src/ecatslv.h
+++ b/SlaveFiles/src/ecatslv.h
@@ -47,9 +47,14 @@ V5.01 : Start file change log
 #include "fc1100hw.h"
 #elif MCI_HW
 #include "mcihw.h"
+#elif KUNBUS_STACK_APPLICATION
+#include  "esc.h"
+#include <ssc_kbStack.h>
 #else
 #include  "esc.h"
 /*CODE_INSERT_START (HW_ACCESS_FILE)*/
+#error Shall not be used !!!
+#include "tieschw.h"
 /*CODE_INSERT_END*/
 #endif

@@ -347,9 +352,9 @@ V5.01 : Start file change log
 #define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_HIGH        0x0081 /**< \brief The slave supply voltage is too high*/
 #define    ALSTATUSCODE_TEMPERATURE_TOO_LOW            0x0080 /**< \brief The slave temperature is too low*/
 #define    ALSTATUSCODE_TEMPERATURE_TOO_HIGH           0x0081 /**< \brief The slave temperature is too high*/
-

-
+
+
 /*---------------------------------------------
 -    Configured Sync Type (0x1C32.1 / 0x1C33.1)
 -----------------------------------------------*/
@@ -368,6 +373,8 @@ V5.01 : Start file change log
 #define     SYNC1_EVENT                         ((UINT16) 0x08) /**< \brief Sync1 event*/
 #define     SM_CHANGE_EVENT                     ((UINT16) 0x10) /**< \brief SyncManager changed event*/
 #define     EEPROM_CMD_PENDING                  ((UINT16) 0x20) /**< \brief EEPROM command pending*/
+#define     WATCHDOG_EXPIRED_EVENT              ((UINT16) 0x40) /**< \brief Watchdog expired event*/
+
 #if MAILBOX_SUPPORTED
 #define     MAILBOX_WRITE_EVENT                 ((UINT16) 0x0100) /**< \brief MBoxOut write event*/
 #define     MAILBOX_READ_EVENT                  ((UINT16) 0x0200) /**< \brief MBoxIn read event*/
@@ -378,7 +385,7 @@ V5.01 : Start file change log
 #define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0100) /**< \brief Output process data write event*/
 #define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0200) /**< \brief Input process data read event*/
 /*ECATCHANGE_END(V5.12) ECAT6*/
-#endif
+#endif

 #if MAILBOX_SUPPORTED
 #define    MAILBOX_WRITE                        0 /**< \brief SyncManager ID for MBoxOut (master to slave)*/
@@ -455,7 +462,7 @@ PROTO    BOOL                           bBootMode; /**< \brief Indicates in slav
 PROTO    BOOL                           bEcatOutputUpdateRunning;  /**< \brief Indicates the OP state, will be set in StartOutputHandler
                                                                                 and reset in StopOutputHandler*/

-PROTO    BOOL                            bEcatInputUpdateRunning;  /**< \brief Indicates the SAFEOP or OP state, will be set in StartInputHandler
+PROTO    BOOL                            bEcatInputUpdateRunning;  /**< \brief Indicates the SAFEOP or OP state, will be set in StartInputHandler
                                                                                 and reset in Stop InputHandler*/

 #if MAX_PD_OUTPUT_SIZE > 0
@@ -471,7 +478,7 @@ PROTO    BOOL                           bDcSyncActive; /**< \brief Indicates tha
 PROTO    INT16                          EsmTimeoutCounter; /**< \brief Counter used to detect an ESM timeout.
                                                            -1 indicates a deactivated counter and 0 is expired*/

-#define MAX_SM_EVENT_MISSED             4 /**< \brief threshold of max missed counter value (0x1C32.11 / 0x1C33.11)*/
+#define MAX_SM_EVENT_MISSED             0xFF /**< \brief threshold of max missed counter value (0x1C32.11 / 0x1C33.11)*/

 #if DC_SUPPORTED
 PROTO BOOL                              bDcRunning; /**< \brief Indicates if Sync0 events are received*/
@@ -537,7 +544,7 @@ PROTO UINT8                             nAlStatus; /**< \brief Contains the actu
 PROTO BOOL                              bExplicitDevIdRequested; /**< \brief Indicates if 0x0120.5 is set*/
 #endif

-PROTO UINT16                            EcatWdValue; /**< \brief Contains the value of the watchdog in ms, will be written in StartInputHandler.
+PROTO UINT16                            EcatWdValue; /**< \brief Contains the value of the watchdog in ms, will be written in StartInputHandler.
                                                                     In case that the ESC watchdog feature is used this variable just indicates if the watchdog is enabled or disabled*/
 #if !ESC_SM_WD_SUPPORTED
 PROTO UINT16                            EcatWdCounter; /**< \brief Counter for the watchdog, will be reset in StartInputHandler and from
diff --git a/SlaveFiles/src/mailbox.c b/SlaveFiles/src/mailbox.c
index ea8b6fc..6bdccf2 100644
--- a/SlaveFiles/src/mailbox.c
+++ b/SlaveFiles/src/mailbox.c
@@ -258,7 +258,7 @@ TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
         pMbx = pQueue->queue[firstInQueue];
         firstInQueue++;
         pQueue->firstInQueue = firstInQueue;
-
+
         if (pQueue->firstInQueue == pQueue->maxQueueSize)
         {
             // Umbruch der Queue
@@ -284,7 +284,7 @@ TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)

 void MBX_Init(void)
 {
-
+
     u16ReceiveMbxSize = MIN_MBX_SIZE;
     u16SendMbxSize = MAX_MBX_SIZE;
     u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
@@ -360,10 +360,13 @@ void MBX_Init(void)
 UINT16 MBX_StartMailboxHandler(void)
 {
     UINT16 result = 0;
-
+
     /* get address of the receive mailbox sync manager (SM0) */
     TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);

+#if DEBUGTRACE
+    printf("%s:%d (%s)\r\n", __FILE__, __LINE__, __FUNCTION__);
+#endif
 #if ESC_32BIT_ACCESS
     /* store size of the receive mailbox */
     u16ReceiveMbxSize     = (UINT16) ((pSyncMan->AddressLength & SM_LENGTH_MASK) >>SM_LENGTH_SHIFT);
@@ -548,7 +551,7 @@ void MBX_StopMailboxHandler(void)
 /*ECATCHANGE_END(V5.12) MBX1*/
         }
     } while (pMbx != NULL);
-
+
     do
     {
         pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
@@ -686,7 +689,7 @@ void MBX_MailboxWriteInd(TMBX MBXMEM *pMbx)
             {
                 /* the master mailbox counter is not incremented by one => return an error*/
                 INC_TEST_CNT(Mbx_MasterMbxCntIncByOne);
-
+
                 /* Mailbox error response: type 0 (mailbox service protocol) */
                 pMbx->MbxHeader.Length     = 4;
                 pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
@@ -882,10 +885,13 @@ void MBX_MailboxReadInd(void)

 void MBX_MailboxRepeatReq(void)
 {
+#if DEBUGTRACE
+    printf("%s:%d (%s)\r\n", __FILE__, __LINE__, __FUNCTION__);
+#endif
     if (psRepeatMbx)
     {
         TMBX MBXMEM *pMbx = psRepeatMbx;
-
+
         /* send mailbox service stored for repeat */
         /* HBu 13.10.06: if a repeat request is received (again) before the previously repeated mailbox telegram
            was read from the master (psStoreMbx != NULL) the next mailbox telegram to be sent is still in the
@@ -960,7 +966,7 @@ UINT8 MBX_MailboxSendReq( TMBX MBXMEM * pMbx, UINT8 flags )
         return ERROR_INVALIDSTATE;
     }

-
+

     ENTER_MBX_CRITICAL;

@@ -1056,7 +1062,7 @@ void MBX_CheckAndCopyMailbox( void )
 #else
     /* get the size of the received mailbox command and acknowledge the event*/
     HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
-
+
     /* the size has to be swapped here, all other bytes of the mailbox service will be swapped later */
     mbxLen = SWAPWORD(mbxLen);
 #endif
@@ -1246,11 +1252,11 @@ UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )

                 /*Get the valid 32Bit address*/
                 UINT32 LastDataAddress = ((mbxSize + MBX_HEADER_SIZE)/4)*4;
-
+
                 /*Copy the buffer to overwrite*/
                 MEMCPY((UINT32 *)&u32dummy,(((UINT8 *)pMbx) + LastDataAddress),(4 - BytesLeft));
             }
-
+
             HW_EscWriteDWord(u32dummy,(u16EscAddrSendMbx + u16SendMbxSize - 4));
 #elif ESC_16BIT_ACCESS
             /*Read last 2 Bytes and write them again (required if low Byte of the WORD were written before)*/
@@ -1259,15 +1265,15 @@ UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
             {
                 /*The last 2Bytes are overlapping the already written buffer*/

-/*ECATCHANGE_START(V5.12) MBX1*/
+/*ECATCHANGE_START(V5.12) MBX1*/
                 /*Get the valid 16Bit address*/
                 UINT32 LastDataAddress = ((mbxSize + MBX_HEADER_SIZE)/2);
-
+
                 /*Copy the buffer to overwrite*/
                 MEMCPY((UINT16 *)&u16dummy,(((UINT16 *)pMbx) + LastDataAddress),(2 - BytesLeft));
-/*ECATCHANGE_END(V5.12) MBX1*/
+/*ECATCHANGE_END(V5.12) MBX1*/
             }
-
+
             HW_EscWriteWord(u16dummy,(u16EscAddrSendMbx + u16SendMbxSize - 2));
 #else
             u8dummy = 0;
--
2.25.1


From 48019e6378a907190f51c408d6cc5057038e34f4 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Thu, 29 Oct 2020 07:47:49 +0100
Subject: [PATCH 02/11] Add LED hook

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/ecatappl.c | 23 +++++++++++++++++++++++
 SlaveFiles/src/ecatappl.h |  3 ++-
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecatappl.c b/SlaveFiles/src/ecatappl.c
index d3b7d54..30833c4 100644
--- a/SlaveFiles/src/ecatappl.c
+++ b/SlaveFiles/src/ecatappl.c
@@ -450,6 +450,7 @@ void PDO_OutputMapping(void)
  \brief and the function is triggered if 1 ms is elapsed
  *////////////////////////////////////////////////////////////////////////////////////////

+#if (!defined SSC_CHECKTIMER) || (SSC_CHECKTIMER==0)
 void ECAT_CheckTimer(void)
 {

@@ -524,6 +525,7 @@ void ECAT_CheckTimer(void)
 #endif //#if !_PIC18
 #endif
 }
+#endif

 #if COE_SUPPORTED
 #if !_PIC18
@@ -1496,6 +1498,25 @@ void MainLoop(void)
         }

 #if !ECAT_TIMER_INT
+#if (defined SSC_CHECKTIMER) && (SSC_CHECKTIMER==1)
+
+        /* pseudoC:
+         * if t>=ECAT_TIMER_INC_P_MS:
+         *     CurTime+=(t/ECAT_TIMER_INC_P_MS);
+         *     HW_ClearTimer;
+         * /pseudoC; */
+
+        ssc_CheckTimer(
+            /* ECAT_CheckTimer */
+            bEcatWaitForAlControlRes, &EsmTimeoutCounter,
+            /* ECAT_SetLedIndication */
+            bEcatOutputUpdateRunning, nAlStatus, &u8EcatRunLed, &u8EcatErrorLed,
+            /* EEPROM */
+            &u16EepromStoreTimeoutValue, &u16EepromStoreTimeoutCounter, pAPPL_EEPROM_Store,
+            /* DC */
+            b32BitDc, &u64Timestamp, &u32CheckForDcOverrunCnt
+            );
+#else
         /* there is no interrupt routine for the hardware timer so check the timer register if the desired cycle elapsed*/
         {
             UINT32 CurTimer = (UINT32)HW_GetTimer();
@@ -1509,6 +1530,8 @@ void MainLoop(void)
         }
 #endif

+#endif
+
 #if DC_SUPPORTED && COE_SUPPORTED
 #if !_PIC18
 /*ECATCHANGE_START(V5.12) COE4*/
diff --git a/SlaveFiles/src/ecatappl.h b/SlaveFiles/src/ecatappl.h
index 9163d1b..ae99954 100644
--- a/SlaveFiles/src/ecatappl.h
+++ b/SlaveFiles/src/ecatappl.h
@@ -157,8 +157,9 @@ PROTO UINT16 EepromReadSize; /**< \brief either 4 or 8 depending on register 0x5



-
+#if (!defined SSC_CHECKTIMER) || (SSC_CHECKTIMER==0)
 PROTO    void       ECAT_CheckTimer(void);
+#endif
 PROTO    void       PDI_Isr(void);
 PROTO    void       Sync0_Isr(void);
 PROTO    void       Sync1_Isr(void);
--
2.25.1


From 63b56f71c7a7da2f5e032d425f7f8669b6bf68d4 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Fri, 30 Oct 2020 13:44:15 +0100
Subject: [PATCH 03/11] Remove compile time warnings

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/sdoserv.c | 60 ++++++++++++++++++++--------------------
 1 file changed, 30 insertions(+), 30 deletions(-)

diff --git a/SlaveFiles/src/sdoserv.c b/SlaveFiles/src/sdoserv.c
index 0054672..03ed133 100644
--- a/SlaveFiles/src/sdoserv.c
+++ b/SlaveFiles/src/sdoserv.c
@@ -314,7 +314,7 @@ static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
                 UINT16 i = 0;

                 if ((nSdoSegBytesToHandle & 0x1) == 0x01)
-                {
+                {
                     // Data0 will be copied to an odd address of pSdoSegData, Data1 to an even address (Segment 2, 4, ...)
                     // Read Data0
                     pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
@@ -323,11 +323,11 @@ static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
                     MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1],pSdoInd->SdoHeader.Data, bytesToSave - 1 );
                 }
                 else
-                {
+                {
                     // Data0 will be copied to an even address of pSdoSegData, Data1 to an odd address (Segment 1, 3,...)
                     // Read Data0 and Data1
                     pSdoSegData[( nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
-
+
                     // Copy Data2 - DataN
                     for (i = 1; i <((bytesToSave + 1)  >> 1); i++)
                     {
@@ -336,7 +336,7 @@ static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
                     }
                 }
 #else
-                MBXMEMCPY( ((UINT8*)pSdoSegData) + (nSdoSegBytesToHandle), pSdoInd->SdoHeader.Data, bytesToSave );
+                MBXMEMCPY( ((UINT8*)pSdoSegData) + (nSdoSegBytesToHandle), pSdoInd->SdoHeader.Data, bytesToSave );
 #endif

                 if ( bSdoSegFollows == FALSE    )
@@ -398,7 +398,7 @@ static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
            pSdoInd->SdoHeader.SegHeader        = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
         }
 /* ECATCHANGE_END(V5.12) ECAT2*/
-
+
         if ( bSdoSegFollows == TRUE )
         {
             /* segments are still expected, nSdoSegBytesToHandle contains the number of received data bytes */
@@ -411,7 +411,7 @@ static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
             nSdoSegService    = 0;
         }
     }
-    else
+    else
     {
         /* the Abort-Response will be sent in SDOS_SdoInd*/
         bSdoSegFollows = FALSE;
@@ -456,10 +456,10 @@ static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
     else
     {
         /* maxData contains the maximum data to be sent with a SDO-Upload Segment response */
-
+
         UINT32 size = 0;
         UINT16 maxData;
-
+
 #if TEST_APPLICATION
         if(IS_TEST_ACTIVE(CoE0_SegSdoByte))
         {
@@ -494,7 +494,7 @@ static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
         // Clear Data0
         pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
         if ((nSdoSegBytesToHandle & 0x1) == 0x01)
-        {
+        {
             // Data starts at odd byte number (Segment 2, 4,...): Data0 is at high byte, Data1 lies at an even address
             // Write Data0
             pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
@@ -502,15 +502,15 @@ static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
             MBXMEMCPY( pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
         }
         else
-        {
+        {
             UINT16 i = 0;
             UINT32 nIndexOffset = nSdoSegBytesToHandle >> 1;
-
+
             // Data starts at even byte number (Segment 1,3, ...): Data0 is at low byte, Data1 lies at an odd address
             // Write Data0
             pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
             // Copy Data1 - DataN
-
+
             for (i = 0; i < (size >> 1);i++)
             {
                 pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
@@ -520,13 +520,13 @@ static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 #else
         MBXMEMCPY( pSdoSegRes->SdoHeader.Data, &(((UINT8*)pSdoSegData)[nSdoSegBytesToHandle]), size );
 #endif
-
+
         /* the SDO Upload Segment header depends if there is still data to be sent */
         pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
         pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;

         /*Clear SDO header*/
-        pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
+        pSdoSegRes->SdoHeader.SegHeader &= (uint8_t)~SEGHEADER_MASK;
 /* ECATCHANGE_START(V5.12) ECAT2*/
         if (bSdoSegFollows)
         {
@@ -573,7 +573,7 @@ static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 /////////////////////////////////////////////////////////////////////////////////////////
 /**
  \param    abort                 Result of the SDO access
- \param    command		         SDO command index
+ \param    command		         SDO command index
  \param    completeAccess        Indicates if complete access was requested
  \param    dataSize              Available data buffer in the response
  \param    objLength             Complete size of the object
@@ -812,7 +812,7 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)

             /*set source*/
             MBXMEMCMP(pSendFrame->Source.b, aMacAdd, (SIZEOF(aMacAdd)));
-#endif
+#endif
             pSendFrame->FrameType = SWAPWORD(ETHERNET_FRAME_TYPE_ARP1_SW);


@@ -828,8 +828,8 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
             pArpIp->lengthProtAddr = SIZEOF(UINT32);
 #endif

-
-
+
+
             pArpIp->opcode = SWAPWORD(ARP_OPCODE_REQUEST_SW);

 #if MBX_16BIT_ACCESS
@@ -858,7 +858,7 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
             }

         }
-        else
+        else
 #endif //#if TEST_APPLICATION && EOE_SUPPORTED


@@ -868,7 +868,7 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
             UINT16 result = 0;
             TMBX MBXMEM *pData = ALLOCMEM(30);

-
+
             VARMEMSET(pData, 0xBA, 30);

             pData->MbxHeader.Length = (30 - MBX_HEADER_SIZE);
@@ -1128,7 +1128,7 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
                                 pSdoResStored = pSdoInd;

                                 /*update command field*/
-                                pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   &= ~SDOHEADER_COMMANDMASK;
+                                pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   &= (uint8_t)~SDOHEADER_COMMANDMASK;
                                 pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
                                 nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
                                 return 0;
@@ -1182,9 +1182,9 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
                             bSdoInWork = TRUE;
                             /* we have to store the buffer and the response header */
                             pSdoResStored = pSdoInd;
-
+
                             /*update command field*/
-                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
+                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    &= (uint8_t)~SDOHEADER_COMMANDMASK;
                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
                             return 0;
                         }
@@ -1211,7 +1211,7 @@ UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
                             pSdoResStored = pSdoInd;

                             /*update command field*/
-                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
+                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    &= (uint8_t)~SDOHEADER_COMMANDMASK;
                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
                             return 0;
                         }
@@ -1374,11 +1374,11 @@ void  SODS_ClearPendingResponse()
         FREEMEM((UINT16 VARMEM *) pSdoSegData);
         pSdoSegData = NULL;
     }
-
+
     nSdoSegBytesToHandle = 0;
     nSdoSegService = 0;
 #endif
-
+
 }
 /* ECATCHANGE_END(V5.12) MBX3*/
 #endif
@@ -1517,7 +1517,7 @@ UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
                         total number of bytes - bytes which will be transmitted with the current response plus the fragment size - 1 (to round up) divided by the size of the following fragments
                         */
                         UINT16 Fragsize = size + 2;
-
+
                         nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
                     }
                     else
@@ -1656,7 +1656,7 @@ UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
             }

         }
-        else
+        else
 #endif //#if TEST_APPLICATION && EOE_SUPPORTED

 #if TEST_APPLICATION
@@ -1693,7 +1693,7 @@ UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
             {
                 /* object exists */
                 UINT16 size = 0;
-
+
                 if ( opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q )
                 {
                     /* object description is requested */
@@ -1712,7 +1712,7 @@ UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
                     {
                         UINT16 Flags = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Res.ObjFlags);

-
+
                         Flags &= ~OBJFLAGS_OBJCODEMASK;
                         Flags |= ((UINT16) OBJCODE_REC) << OBJFLAGS_OBJCODESHIFT;

--
2.25.1


From cf14b367c77a5e1213fba6614ec0a5bfd43d0eed Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Tue, 1 Dec 2020 17:32:00 +0100
Subject: [PATCH 04/11] Remove some warnings with TI compiler

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/ecat_def.h | 2 +-
 SlaveFiles/src/ecatappl.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 20e9ab3..5c9765c 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -508,7 +508,7 @@ INT64: Should be adapted to the integer64 type of the microcontroller */
 /**
 CHAR: Should be adapted to the character type of the microcontroller */
 #ifndef CHAR
-#define CHAR                                      int8_t
+#define CHAR                                      char
 #endif

 /**
diff --git a/SlaveFiles/src/ecatappl.c b/SlaveFiles/src/ecatappl.c
index 30833c4..861d887 100644
--- a/SlaveFiles/src/ecatappl.c
+++ b/SlaveFiles/src/ecatappl.c
@@ -709,7 +709,7 @@ void PDI_Isr(void)
             if (u16SmEventMissedCounter > 0)
             { /* fun = 4 */
                 u16SmEventMissedCounter--;
-            } /* if (u16SmEventMissedCounter > 0) /* fun = 3 */
+            } /* if (u16SmEventMissedCounter > 0) */ /* fun = 3 */
 #endif //#else #if COE_SUPPORTED /* preif = 3 */
 #endif //#if DC_SUPPORTED /* preif = 2 */
         } /* if (ALEvent & PROCESS_INPUT_EVENT) */ /* fun = 2 */
--
2.25.1


From 20843c32a92fbceaaa497ee8025dbcaf2a805e11 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Mon, 25 Jan 2021 13:38:05 +0100
Subject: [PATCH 05/11] EtherCAT Slave 1.0.9.7

---
 SlaveFiles/src/cia402appl.c | 8 ++++++++
 SlaveFiles/src/cia402appl.h | 3 ++-
 SlaveFiles/src/ecat_def.h   | 4 ++--
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/SlaveFiles/src/cia402appl.c b/SlaveFiles/src/cia402appl.c
index 2bad980..eb4efe8 100644
--- a/SlaveFiles/src/cia402appl.c
+++ b/SlaveFiles/src/cia402appl.c
@@ -195,6 +195,9 @@ UINT16 CiA402_Init(void)
         {
             BOOL bObjectFound = TRUE;

+            /* Below to fix the compiler warning when CiA402_DEVICE is enabled */
+            (void) bObjectFound;
+
             switch(pDiCEntry->Index)
             {
             case 0x1600:
@@ -934,8 +937,12 @@ void CiA402_Application(TCiA402Axis *pCiA402Axis)
     {
 #ifdef CiA402_MOTOR_CONTROL
         CiA402_MotionControl(pCiA402Axis);
+#else
+#ifdef TI_CiA402_3AXIS_MOTOR_CONTROL
+        TI_CiA402_3axisMotionControl(pCiA402Axis);
 #else
         CiA402_DummyMotionControl(pCiA402Axis);
+#endif
 #endif
 	}
 }
@@ -1600,6 +1607,7 @@ void APPL_Application(void)
     {
             if (LocalAxes[i].bAxisIsActive)
             {
+				LocalAxes[i].axisIndex = i;
                 CiA402_Application(&LocalAxes[i]);
             }
     }
diff --git a/SlaveFiles/src/cia402appl.h b/SlaveFiles/src/cia402appl.h
index 0e1f9fc..9b42b89 100644
--- a/SlaveFiles/src/cia402appl.h
+++ b/SlaveFiles/src/cia402appl.h
@@ -325,7 +325,7 @@ V5.01 : Start file change log
 //9 to 32767        RESERVED


-#define MAX_AXES    2 /**< \brief Number of supported axes*/
+#define MAX_AXES    3 /**< \brief Number of supported axes*/

 /*CODE_INSERT_START (FILE_PACKED_START)*/
 #if FC1100_HW
@@ -651,6 +651,7 @@ typedef struct

     CiA402Objects        Objects; /**< \brief CiA402 Axis object variable*/
     TOBJECT OBJMEM        * ObjDic; /**< \brief Pointer to Axis specific object dictionary*/
+	UINT16               axisIndex; /**< \brief CiA402 Axis ===================================================================*/
 }
 TCiA402Axis, *pTCiA402Axis;
 /** @}*/
diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 5c9765c..9f892cf 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -23,7 +23,7 @@
 #include <stdbool.h>
 #include <string.h>
 #include <stdio.h>
-#if defined(SOC_AM65XX)
+#if defined(SOC_AM65XX) || defined(SOC_AM64X)
 #if !defined (__aarch64__)
 /* Only for R5F build. */
 #include <stdint.h>
@@ -955,7 +955,7 @@ PRODUCT_CODE: Object 0x1018 SI2 (EtherCAT product code) */
  #elif TIESC_HW
   #if defined (TIESC_SPI_MASTER_MODE)
    #define PRODUCT_CODE                              0x54490081
-  #elif defined (SOC_K2G) || (SOC_AM65XX)
+  #elif defined (SOC_K2G) || (SOC_AM65XX) || defined (SOC_AM64X)
    #define PRODUCT_CODE                              0x54490004
   #elif defined (SOC_AM574x) || defined (SOC_AM572x) || defined (SOC_AM571x)
    #define PRODUCT_CODE                              0x54490003
--
2.25.1


From 8491479946c9f9911b9e9ed6e415475bd7c9f194 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Mon, 22 Feb 2021 21:24:14 +0100
Subject: [PATCH 06/11] Fix minimal cycle time to 150usec since faster we
 cannot achieve using DC

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/ecat_def.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 9f892cf..03dfb42 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -1126,7 +1126,7 @@ MAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for
 MIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
 In case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
 #ifndef MIN_PD_CYCLE_TIME
-#define MIN_PD_CYCLE_TIME                         0x79E0// 31.2us 0x7A120
+#define MIN_PD_CYCLE_TIME                         0x249F0 /* MIN PD Cycle KB */ //0x79E0// 31.2us 0x7A120
 #endif

 /**
--
2.25.1


From a40f53d98c4b98573ffd6ce0ab1a696c8bcef7a4 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Wed, 24 Feb 2021 10:16:57 +0100
Subject: [PATCH 07/11] Set min cycle time to 250usec

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/ecat_def.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 03dfb42..c638006 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -1126,7 +1126,7 @@ MAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for
 MIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
 In case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
 #ifndef MIN_PD_CYCLE_TIME
-#define MIN_PD_CYCLE_TIME                         0x249F0 /* MIN PD Cycle KB */ //0x79E0// 31.2us 0x7A120
+#define MIN_PD_CYCLE_TIME                         0x3D090 /* MIN PD Cycle KB 250usec */ //0x79E0// 31.2us 0x7A120
 #endif

 /**
--
2.25.1


From ecb65690b18d2b833c0d836080c459c453e25f7b Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Mon, 27 Sep 2021 10:02:37 +0200
Subject: [PATCH 08/11] DTKEC-403 change minimum DC cycle time to 50usec

---
 SlaveFiles/src/ecat_def.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index c638006..0c62483 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -1126,7 +1126,7 @@ MAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for
 MIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
 In case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
 #ifndef MIN_PD_CYCLE_TIME
-#define MIN_PD_CYCLE_TIME                         0x3D090 /* MIN PD Cycle KB 250usec */ //0x79E0// 31.2us 0x7A120
+#define MIN_PD_CYCLE_TIME                         0xC350 /* MIN PD Cycle KB 250usec */ //0x79E0// 31.2us 0x7A120
 #endif

 /**
--
2.25.1


From f61591f1b8ed589ddf3cd87ccb0993157b401011 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Mon, 27 Sep 2021 17:04:49 +0200
Subject: [PATCH 09/11] DTKEC-403 reset MAX_SM_EVENT_MISSED to original value =
 4

---
 SlaveFiles/src/ecatslv.h | 1172 +++++++++++++++++++-------------------
 1 file changed, 586 insertions(+), 586 deletions(-)

diff --git a/SlaveFiles/src/ecatslv.h b/SlaveFiles/src/ecatslv.h
index bd4c0a4..6257b2a 100644
--- a/SlaveFiles/src/ecatslv.h
+++ b/SlaveFiles/src/ecatslv.h
@@ -1,586 +1,586 @@
-/*
-* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
-* The corresponding license agreement applies. This hint shall not be removed.
-*/
-
-/**
- * \addtogroup ESM EtherCAT State Machine
- * @{
- */
-
-/**
-\file ecatslv.h
-\author EthercatSSC@beckhoff.com
-
-\version 5.12
-
-<br>Changes to version V5.11:<br>
-V5.12 COE4: add timestamp object (0x10F8) and update diagnosis handling<br>
-V5.12 ECAT6: remove mailbox SyncManager if no mailbox is supported (SM0 Output, SM1 Input)<br>
-<br>Changes to version V5.10:<br>
-V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
-V5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
-V5.11 ECAT9: add new AL Status Codes (ALSTATUSCODE_FW_SII_NOT_MATCH/0x0006, ALSTATUSCODE_FW_UPDATE_FAILED / 0x0007)<br>
-V5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 (SM2 sync)"<br>
-V5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManChannel()"", ""HW_GetSyncMan()"", ""HW_ResetALEventMask()"", ""HW_SetALEventMask()"" to ecatalv.c"<br>
-<br>Changes to version V5.01:<br>
-V5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 to UINT16 (according ETG.1020)<br>
-V5.10 ECAT12: Add new AL Status Codes (0x2E,0x52,0x70)<br>
-V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
-              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
-              Update 0x1C3x entries<br>
-<br>Changes to version - :<br>
-V5.01 : Start file change log
- */
-
-/*-----------------------------------------------------------------------------------------
-------
-------    Includes
-------
------------------------------------------------------------------------------------------*/
-
-#include "ecat_def.h"
-
-#if EL9800_HW
-#include "el9800hw.h"
-#elif FC1100_HW
-#include "fc1100hw.h"
-#elif MCI_HW
-#include "mcihw.h"
-#elif KUNBUS_STACK_APPLICATION
-#include  "esc.h"
-#include <ssc_kbStack.h>
-#else
-#include  "esc.h"
-/*CODE_INSERT_START (HW_ACCESS_FILE)*/
-#error Shall not be used !!!
-#include "tieschw.h"
-/*CODE_INSERT_END*/
-#endif
-
-#ifndef _ECATSLV_H_
-#define _ECATSLV_H_
-
-
-/*-----------------------------------------------------------------------------------------
-------
-------    Defines and Types
-------
------------------------------------------------------------------------------------------*/
-
-#ifndef OBJGETNEXTSTR
-    /* the old definition was not working with all compilers */
-    /* old:    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )( ((UINT32) p) + OBJSTRLEN( (OBJCONST CHAR OBJMEM *) p ) + 1 ) ) */
-    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )(  &((p)[OBJSTRLEN( (OBJCONST CHAR OBJMEM *) (p) ) + 1]) ) ) /**< \brief Macro to get next name within the objetc name string*/
-#endif
-
-#if BIG_ENDIAN_FORMAT
-#ifndef LO_BYTE
-    #define    LO_BYTE                            1 /**< \brief LowByte within an WORD*/
-#endif
-
-#ifndef HI_BYTE
-    #define    HI_BYTE                            0 /**< \brief HighByte within an WORD*/
-#endif
-
-#ifndef LOLO_BYTE
-    #define    LOLO_BYTE                          3 /**< \brief LowLowByte within an DWORD*/
-#endif
-
-#ifndef LOHI_BYTE
-    #define    LOHI_BYTE                          2 /**< \brief LowHighByte within an DWORD*/
-#endif
-
-#ifndef HILO_BYTE
-    #define    HILO_BYTE                         1 /**< \brief HighLowByte within an DWORD*/
-#endif
-
-#ifndef HIHI_BYTE
-    #define    HIHI_BYTE                          0 /**< \brief HighHighByte within an DWORD*/
-#endif
-
-#ifndef LO_WORD
-    #define    LO_WORD                            1 /**< \brief LowWord within an DWORD*/
-#endif
-
-#ifndef HI_WORD
-    #define    HI_WORD                            0 /**< \brief HighWord within an DWORD*/
-#endif
-
-#ifndef SWAPWORD
-    #define    SWAPWORD(x)                        ((UINT16)(((((UINT16)(x))&0xFF)<<8)+((((UINT16)(x))&0xFF00)>>8))) /**< \brief Macro to swap a WORD*/
-#endif
-
-#ifndef SWAPDWORD
-    #define    SWAPDWORD(x)                    ((UINT32)(((((UINT32)(x))&0xFF)<<24)+((((UINT32)(x))&0xFF00)<<8)+((((UINT32)(x))&0xFF0000)>>8)+((((UINT32)(x))&0xFF000000)>>24))) /**< \brief Macro to swap a DWORD*/
-#endif
-#else
-#ifndef LO_BYTE
-    #define    LO_BYTE                            0 /**< \brief LowByte within an WORD*/
-#endif
-
-#ifndef HI_BYTE
-    #define    HI_BYTE                            1 /**< \brief HighByte within an WORD*/
-#endif
-
-#ifndef LOLO_BYTE
-    #define    LOLO_BYTE                          0 /**< \brief LowLowByte within an DWORD*/
-#endif
-
-#ifndef LOHI_BYTE
-    #define    LOHI_BYTE                          1 /**< \brief LowHighByte within an DWORD*/
-#endif
-
-#ifndef HILO_BYTE
-    #define    HILO_BYTE                         2 /**< \brief HighLowByte within an DWORD*/
-#endif
-
-#ifndef HIHI_BYTE
-    #define    HIHI_BYTE                          3 /**< \brief HighHighByte within an DWORD*/
-#endif
-
-#ifndef LO_WORD
-    #define    LO_WORD                            0 /**< \brief LowWord within an DWORD*/
-#endif
-
-#ifndef HI_WORD
-    #define    HI_WORD                            1 /**< \brief HighWord within an DWORD*/
-#endif
-
-#ifndef SWAPWORD
-    #define    SWAPWORD(x)                        (x) /**< \brief Macro to swap a WORD*/
-#endif
-
-#ifndef SWAPDWORD
-    #define    SWAPDWORD(x)                     (x) /**< \brief Macro to swap a DWORD*/
-#endif
-#endif //BIG_ENDIAN_FORMAT
-
-#ifndef LOBYTE
-    #define    LOBYTE(x)                        ((x)&0xFF) /**< \brief LowByte mask*/
-#endif
-
-#ifndef HIBYTE
-    #define    HIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief HighwByte mask*/
-#endif
-
-#ifndef LOLOBYTE
-    #define    LOLOBYTE(x)                        ((x)&0xFF)/**< \brief LowLowByte mask*/
-#endif
-
-#ifndef LOHIBYTE
-    #define    LOHIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief LowHighByte mask*/
-#endif
-
-#ifndef HILOBYTE
-    #define    HILOBYTE(x)                        (((x)&0xFF0000)>>16)/**< \brief HighLowByte mask*/
-#endif
-
-#ifndef HIHIBYTE
-    #define    HIHIBYTE(x)                        (((x)&0xFF000000)>>24)/**< \brief HighHighByte mask*/
-#endif
-
-#ifndef LOWORD
-    #define    LOWORD(x)                        ((x)&0xFFFF)/**< \brief LowWord mask*/
-#endif
-
-#ifndef HIWORD
-    #define    HIWORD(x)                        (((x)&0xFFFF0000)>>16)/**< \brief HighByte mask*/
-#endif
-
-#ifndef BIT2BYTE
-    #define    BIT2BYTE(x)        (((x)+7)>>3) /**< \brief Marco to convert Bit size to Byte size (round up)*/
-#endif
-
-#ifndef BYTE2BIT
-    #define    BYTE2BIT(x)        ((x)<<3) /**< \brief Marco to convert Byte size to Bit size*/
-#endif
-
-#ifndef BIT2WORD
-    #define    BIT2WORD(x)        (((x)+15)>>4) /**< \brief Marco to convert Bit size to Word size (round up)*/
-#endif
-
-#ifndef BYTE2WORD
-    #define    BYTE2WORD(x)    (((x)+1)>>1) /**< \brief Marco to convert Bytes size to Word size (round up)*/
-#endif
-
-#ifndef ROUNDUPBYTE2WORD
-    #define    ROUNDUPBYTE2WORD(x)    ((((x)+1)>>1)<<1) /**< \brief Round up Byte size to even number of Words*/
-#endif
-
-
-/*---------------------------------------------
--    State defines
------------------------------------------------*/
-#define     STATE_INIT                        ((UINT8) 0x01) /**< \brief State INIT*/
-#define     STATE_PREOP                       ((UINT8) 0x02) /**< \brief State PreOP*/
-#define     STATE_BOOT                        ((UINT8) 0x03) /**< \brief State BOOT*/
-#define     STATE_SAFEOP                      ((UINT8) 0x04) /**< \brief State SafeOP*/
-#define     STATE_OP                          ((UINT8) 0x08) /**< \brief State OP*/
-
-#define     STATE_MASK                        ((UINT8) 0x0F) /**< \brief State mask*/
-#define     STATE_CHANGE                      ((UINT8) 0x10) /**< \brief State change (Error indication/acknowledge) mask and value*/
-#define     STATE_DEVID                       ((UINT8) 0x20) /**< \brief Request/response Explicit device ID*/
-
-#define     BOOT_2_INIT                       ((UINT8)((STATE_BOOT) << 4) | (STATE_INIT)) /**< \brief State transition BOOT to INIT*/
-#define     BOOT_2_PREOP                      ((UINT8)((STATE_BOOT) << 4) | (STATE_PREOP)) /**< \brief State transition BOOT to INIT*/
-#define     BOOT_2_SAFEOP                     ((UINT8)((STATE_BOOT) << 4) | (STATE_SAFEOP)) /**< \brief State transition BOOT to INIT*/
-#define     BOOT_2_OP                         ((UINT8)((STATE_BOOT) << 4) | (STATE_OP)) /**< \brief State transition BOOT to INIT*/
-
-#define     INIT_2_BOOT                       ((UINT8)((STATE_INIT) << 4) | (STATE_BOOT)) /**< \brief State transition INIT to BOOT*/
-#define     PREOP_2_BOOT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_BOOT)) /**< \brief State transition PREOP to BOOT*/
-#define     SAFEOP_2_BOOT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_BOOT)) /**< \brief State transition SAFEOP to BOOT*/
-#define     OP_2_BOOT                         ((UINT8)((STATE_OP) << 4) | (STATE_BOOT)) /**< \brief State transition OP to BOOT*/
-
-#define     INIT_2_INIT                       ((UINT8)((STATE_INIT) << 4) | (STATE_INIT)) /**< \brief State transition INIT to INIT*/
-#define     INIT_2_PREOP                      ((UINT8)((STATE_INIT) << 4) | (STATE_PREOP)) /**< \brief State transition INIT to PREOP*/
-#define     INIT_2_SAFEOP                     ((UINT8)((STATE_INIT) << 4) | (STATE_SAFEOP)) /**< \brief State transition INIT to SAFEOP*/
-#define     INIT_2_OP                         ((UINT8)((STATE_INIT) << 4) | (STATE_OP)) /**< \brief State transition INIT to OP*/
-
-#define     PREOP_2_INIT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_INIT)) /**< \brief State transition PREOP to INIT*/
-#define     PREOP_2_PREOP                     ((UINT8)((STATE_PREOP) << 4) | (STATE_PREOP)) /**< \brief State transition PREOP to PREOP*/
-#define     PREOP_2_SAFEOP                    ((UINT8)((STATE_PREOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition PREOP to SAFEOP*/
-#define     PREOP_2_OP                        ((UINT8)((STATE_PREOP) << 4) | (STATE_OP)) /**< \brief State transition PREOP to OP*/
-
-#define     SAFEOP_2_INIT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_INIT)) /**< \brief State transition SAFEOP to INIT*/
-#define     SAFEOP_2_PREOP                    ((UINT8)((STATE_SAFEOP) << 4) | (STATE_PREOP)) /**< \brief State transition SAFEOP to PREOP*/
-#define     SAFEOP_2_SAFEOP                   ((UINT8)((STATE_SAFEOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition SAFEOP to SAFEOP*/
-#define     SAFEOP_2_OP                       ((UINT8)((STATE_SAFEOP) << 4) |( STATE_OP)) /**< \brief State transition SAFEOP to OP*/
-
-#define     OP_2_INIT                         ((UINT8)((STATE_OP) << 4) | (STATE_INIT)) /**< \brief State transition OP to INIT*/
-#define     OP_2_PREOP                        ((UINT8)((STATE_OP) << 4) | (STATE_PREOP)) /**< \brief State transition OP to PREOP*/
-#define     OP_2_SAFEOP                       ((UINT8)((STATE_OP) << 4) | (STATE_SAFEOP)) /**< \brief State transition OP to SAFEOP*/
-#define     OP_2_OP                           ((UINT8)((STATE_OP) << 4) | (STATE_OP)) /**< \brief State transition OP to OP*/
-
-
-/*-------------------------------------------------------------------------------------------------------------------------
-
- ESM transition error codes
-
-*/
-
-#define    SYNCMANCHODDADDRESS                                     0x00 /**< \brief Emergency and Diagnosis code for an odd SyncManager address*/
-#define    SYNCMANCHADDRESS                                         0x01 /**< \brief Emergency and Diagnosis code for an invalid SyncManager address*/
-#define    SYNCMANCHSIZE                                            0x02 /**< \brief Emergency and Diagnosis code for an invalid  SyncManager size*/
-#define    SYNCMANCHSETTINGS                                        0x03 /**< \brief Emergency and Diagnosis code for an invalid SyncManager settings*/
-#define    ERROR_SYNCMANCH(code, channel)                    ((code)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
-#define    ERROR_SYNCMANCHODDADDRESS(channel)                ((SYNCMANCHODDADDRESS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
-#define    ERROR_SYNCMANCHADDRESS(channel)                    ((SYNCMANCHADDRESS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
-#define    ERROR_SYNCMANCHSIZE(channel)                          ((SYNCMANCHSIZE)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
-#define    ERROR_SYNCMANCHSETTINGS(channel)                    ((SYNCMANCHSETTINGS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
-#define    ERROR_SYNCTYPES                                        0x80 /**< \brief Emergency and Diagnosis code for an invalid Sync types*/
-#define    ERROR_DCSYNCCONTROL                                    0x81 /**< \brief Emergency and Diagnosis code for an invalid DC Sync control*/
-#define    ERROR_DCSYNC0CYCLETIME                                0x82 /**< \brief Emergency and Diagnosis code for an invalid Sync0 cycle time*/
-#define    ERROR_DCSYNC1CYCLETIME                                0x83 /**< \brief Emergency and Diagnosis code for an invalid Sync1 cycle time*/
-#define    ERROR_DCCYCLEPARAMETER                                0x84 /**< \brief Emergency and Diagnosis code for an invalid Cycle parameter*/
-#define    ERROR_DCLATCHCONTROL                                    0x85 /**< \brief Emergency and Diagnosis code for an invalid Latch control*/
-
-#define    ERROR_INVALIDSTATE                                    0xF0 /**< \brief Emergency and Diagnosis code for an invalid State*/
-#define    ERROR_NOMEMORY                                            0xF1 /**< \brief Emergency and Diagnosis code for no memory*/
-#define    ERROR_OBJECTDICTIONARY                                0xF2 /**< \brief Emergency and Diagnosis code for generic object dictionary error*/
-#define    ERROR_NOSYNCMANACCESS                                0xF3 /**< \brief Emergency and Diagnosis code for no SyncManager access*/
-#define    ERROR_NOOFRXPDOS                                        0xF4 /**< \brief Emergency and Diagnosis code for no RxPDOs*/
-#define    ERROR_NOOFTXPDOS                                        0xF5 /**< \brief Emergency and Diagnosis code for no TxPDOs*/
-#define    ERROR_STATECHANGE                                        0xF6 /**< \brief Emergency and Diagnosis code state change error*/
-
-#define    NOERROR_NOSTATECHANGE                                0xFE /**< \brief Indicates no state change*/
-#define    NOERROR_INWORK                                            0xFF /**< \brief Indication for no error but operation is pending*/
-
-#define    EMCY_SM_ERRORCODE                                        0xA000 /**< \brief Emergency and Diagnosis code for an SyncManager error*/
-#define    EMCY_SM_DEVICESPECIFIC                                0xFF00 /**< \brief Emergency and Diagnosis code for a device specific error*/
-
-
-/*---------------------------------------------
--    AL Status Codes
------------------------------------------------*/
-#define    ALSTATUSCODE_NOERROR                        0x0000 /**< \brief No error*/
-#define    ALSTATUSCODE_UNSPECIFIEDERROR               0x0001 /**< \brief Unspecified error*/
-#define    ALSTATUSCODE_NOMEMORY                       0x0002 /**< \brief No Memory*/
-#define    ALSTATUSCODE_INVALID_REVISION               0x0004 /**< \brief Output/Input mapping is not valid for this hardware or software revision (0x1018:03)*/
-#define    ALSTATUSCODE_FW_SII_NOT_MATCH               0x0006 /**< \brief Firmware and EEPROM do not match. Slave needs BOOT-INIT transition*/
-#define    ALSTATUSCODE_FW_UPDATE_FAILED               0x0007 /**< \brief Firmware update not successful. Old firmware still running*/
-#define    ALSTATUSCODE_INVALIDALCONTROL               0x0011 /**< \brief Invalid requested state change*/
-#define    ALSTATUSCODE_UNKNOWNALCONTROL               0x0012 /**< \brief Unknown requested state*/
-#define    ALSTATUSCODE_BOOTNOTSUPP                    0x0013 /**< \brief Bootstrap not supported*/
-#define    ALSTATUSCODE_NOVALIDFIRMWARE                0x0014 /**< \brief No valid firmware*/
-#define    ALSTATUSCODE_INVALIDMBXCFGINBOOT            0x0015 /**< \brief Invalid mailbox configuration (BOOT state)*/
-#define    ALSTATUSCODE_INVALIDMBXCFGINPREOP           0x0016 /**< \brief Invalid mailbox configuration (PreOP state)*/
-#define    ALSTATUSCODE_INVALIDSMCFG                   0x0017 /**< \brief Invalid sync manager configuration*/
-#define    ALSTATUSCODE_NOVALIDINPUTS                  0x0018 /**< \brief No valid inputs available*/
-#define    ALSTATUSCODE_NOVALIDOUTPUTS                 0x0019 /**< \brief No valid outputs*/
-#define    ALSTATUSCODE_SYNCERROR                      0x001A /**< \brief Synchronization error*/
-#define    ALSTATUSCODE_SMWATCHDOG                     0x001B /**< \brief Sync manager watchdog*/
-#define    ALSTATUSCODE_SYNCTYPESNOTCOMPATIBLE         0x001C /**< \brief Invalid Sync Manager Types*/
-#define    ALSTATUSCODE_INVALIDSMOUTCFG                0x001D /**< \brief Invalid Output Configuration*/
-#define    ALSTATUSCODE_INVALIDSMINCFG                 0x001E /**< \brief Invalid Input Configuration*/
-#define    ALSTATUSCODE_INVALIDWDCFG                   0x001F /**< \brief Invalid Watchdog Configuration*/
-#define    ALSTATUSCODE_WAITFORCOLDSTART               0x0020 /**< \brief Slave needs cold start*/
-#define    ALSTATUSCODE_WAITFORINIT                    0x0021 /**< \brief Slave needs INIT*/
-#define    ALSTATUSCODE_WAITFORPREOP                   0x0022 /**< \brief Slave needs PREOP*/
-#define    ALSTATUSCODE_WAITFORSAFEOP                  0x0023 /**< \brief Slave needs SAFEOP*/
-#define    ALSTATUSCODE_INVALIDINPUTMAPPING            0x0024 /**< \brief Invalid Input Mapping*/
-#define    ALSTATUSCODE_INVALIDOUTPUTMAPPING           0x0025 /**< \brief Invalid Output Mapping*/
-#define    ALSTATUSCODE_INCONSISTENTSETTINGS           0x0026 /**< \brief Inconsistent Settings*/
-#define    ALSTATUSCODE_FREERUNNOTSUPPORTED            0x0027 /**< \brief FreeRun not supported*/
-#define    ALSTATUSCODE_SYNCHRONNOTSUPPORTED           0x0028 /**< \brief SyncMode not supported*/
-#define    ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE        0x0029 /**< \brief FreeRun needs 3Buffer Mode*/
-#define    ALSTATUSCODE_BACKGROUNDWATCHDOG             0x002A /**< \brief Background Watchdog*/
-#define    ALSTATUSCODE_NOVALIDINPUTSANDOUTPUTS        0x002B /**< \brief No Valid Inputs and Outputs*/
-#define    ALSTATUSCODE_FATALSYNCERROR                 0x002C /**< \brief Fatal Sync Error*/
-#define    ALSTATUSCODE_NOSYNCERROR                    0x002D /**< \brief No Sync Error*/
-#define    ALSTATUSCODE_CYCLETIMETOOSMALL              0x002E /**< \brief EtherCAT cycle time smaller Minimum Cycle Time supported by slave*/
-#define    ALSTATUSCODE_DCINVALIDSYNCCFG               0x0030 /**< \brief Invalid DC SYNCH Configuration*/
-#define    ALSTATUSCODE_DCINVALIDLATCHCFG              0x0031 /**< \brief Invalid DC Latch Configuration*/
-#define    ALSTATUSCODE_DCPLLSYNCERROR                 0x0032 /**< \brief PLL Error*/
-#define    ALSTATUSCODE_DCSYNCIOERROR                  0x0033 /**< \brief DC Sync IO Error*/
-#define    ALSTATUSCODE_DCSYNCMISSEDERROR              0x0034 /**< \brief DC Sync Timeout Error*/
-#define    ALSTATUSCODE_DCINVALIDSYNCCYCLETIME         0x0035 /**< \brief DC Invalid Sync Cycle Time*/
-#define    ALSTATUSCODE_DCSYNC0CYCLETIME               0x0036 /**< \brief DC Sync0 Cycle Time*/
-#define    ALSTATUSCODE_DCSYNC1CYCLETIME               0x0037 /**< \brief DC Sync1 Cycle Time*/
-#define    ALSTATUSCODE_MBX_AOE                        0x0041 /**< \brief MBX_AOE*/
-#define    ALSTATUSCODE_MBX_EOE                        0x0042 /**< \brief MBX_EOE*/
-#define    ALSTATUSCODE_MBX_COE                        0x0043 /**< \brief MBX_COE*/
-#define    ALSTATUSCODE_MBX_FOE                        0x0044 /**< \brief MBX_FOE*/
-#define    ALSTATUSCODE_MBX_SOE                        0x0045 /**< \brief MBX_SOE*/
-#define    ALSTATUSCODE_MBX_VOE                        0x004F /**< \brief MBX_VOE*/
-#define    ALSTATUSCODE_EE_NOACCESS                    0x0050 /**< \brief EEPROM no access*/
-#define    ALSTATUSCODE_EE_ERROR                       0x0051 /**< \brief EEPROM Error*/
-#define    ALSTATUSCODE_EXT_HARDWARE_NOT_READY         0x0052 /**< \brief External hardware not ready. This AL Status Code should be used if the EtherCAT-Slave refused the state transition due to an external connection to another device or signal is missing*/
-#define    ALSTATUSCODE_DEVICE_IDENT_VALUE_UPDATED     0x0061 /**< \brief In legacy identification mode (dip switch mapped to register 0x12) this error is returned if the EEPROM ID value does not match to dipswitch value*/
-#define    ALSTATUSCODE_MODULE_ID_LIST_NOT_MATCH       0x0070 /**< \brief Detected Module Ident List (0xF030) and Configured Module Ident List (0xF050) does not match*/
-#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_LOW         0x0080 /**< \brief The slave supply voltage is too low*/
-#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_HIGH        0x0081 /**< \brief The slave supply voltage is too high*/
-#define    ALSTATUSCODE_TEMPERATURE_TOO_LOW            0x0080 /**< \brief The slave temperature is too low*/
-#define    ALSTATUSCODE_TEMPERATURE_TOO_HIGH           0x0081 /**< \brief The slave temperature is too high*/
-
-
-
-/*---------------------------------------------
--    Configured Sync Type (0x1C32.1 / 0x1C33.1)
------------------------------------------------*/
-#define     SYNCTYPE_FREERUN            0x0000 /**< \brief Sync type FreeRun*/
-#define     SYNCTYPE_SM_SYNCHRON        0x0001 /**< \brief SyncManager synchron (synchron to the corresponding SM, 0x1C32.1 -> SM2 ; 0x1C33.1 -> SM3)  */
-#define     SYNCTYPE_SM2_SYNCHRON       0x0022 /**< \brief SyncManager2 synchron (only used for 0x1C33.1)*/
-#define     SYNCTYPE_DCSYNC0            0x0002 /**< \brief Sync type Sync0 synchron*/
-#define     SYNCTYPE_DCSYNC1            0x0003 /**< \brief Sync type Sync1 synchron*/
-
-
-/*---------------------------------------------
--    AL Event masks
------------------------------------------------*/
-#define     AL_CONTROL_EVENT                    ((UINT16) 0x01) /**< \brief AL Control event*/
-#define     SYNC0_EVENT                         ((UINT16) 0x04) /**< \brief Sync0 event*/
-#define     SYNC1_EVENT                         ((UINT16) 0x08) /**< \brief Sync1 event*/
-#define     SM_CHANGE_EVENT                     ((UINT16) 0x10) /**< \brief SyncManager changed event*/
-#define     EEPROM_CMD_PENDING                  ((UINT16) 0x20) /**< \brief EEPROM command pending*/
-#define     WATCHDOG_EXPIRED_EVENT              ((UINT16) 0x40) /**< \brief Watchdog expired event*/
-
-#if MAILBOX_SUPPORTED
-#define     MAILBOX_WRITE_EVENT                 ((UINT16) 0x0100) /**< \brief MBoxOut write event*/
-#define     MAILBOX_READ_EVENT                  ((UINT16) 0x0200) /**< \brief MBoxIn read event*/
-#define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0400) /**< \brief Output process data write event*/
-#define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0800) /**< \brief Input process data read event*/
-#else
-/*ECATCHANGE_START(V5.12) ECAT6*/
-#define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0100) /**< \brief Output process data write event*/
-#define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0200) /**< \brief Input process data read event*/
-/*ECATCHANGE_END(V5.12) ECAT6*/
-#endif
-
-#if MAILBOX_SUPPORTED
-#define    MAILBOX_WRITE                        0 /**< \brief SyncManager ID for MBoxOut (master to slave)*/
-#define    MAILBOX_READ                         1 /**< \brief SyncManager ID for MBoxIn (slave to master)*/
-#define    PROCESS_DATA_OUT                     2 /**< \brief SyncManager ID for output process data (master to slave)*/
-#define    PROCESS_DATA_IN                      3 /**< \brief SyncManager ID for input process data (slave to master)*/
-#else
-/*ECATCHANGE_START(V5.12) ECAT6*/
-#define    PROCESS_DATA_OUT                     0 /**< \brief SyncManager ID for output process data (master to slave)*/
-#define    PROCESS_DATA_IN                      1 /**< \brief SyncManager ID for input process data (slave to master)*/
-/*ECATCHANGE_END(V5.12) ECAT6*/
-#endif
-
-
-
-
-#if UC_SET_ECAT_LED
-/*---------------------------------------------
--     Codes for LED
-      bit 7: invert flag
-      bit 6: toggle    (if toggle == 1 and number of flashes == 0 => infinite toggle)
-      bit 5: fast toggle flag (50ms cycle)
-      bit 4-0: number of flashes
------------------------------------------------*/
-#define    LED_OFF                      0x00 /**< \brief LED off*/
-#define    LED_FLICKERING               0x60 /**< \brief LED flickering*/
-#define    LED_BLINKING                 0x40 /**< \brief LED blinking*/
-#define    LED_SINGLEFLASH              0x41 /**< \brief LED single flash*/
-#define    LED_DOUBLEFLASH              0x42 /**< \brief LED double flash*/
-#define    LED_INVERT_DOUBLEFLASH       0xC2 /**< \brief LED invert double flash*/
-#define    LED_ON                       0x01 /**< \brief LED on*/
-
-#elif ESC_SUPPORT_ECAT_LED
-#define    LED_OFF                      0x00 /**< \brief LED off*/
-#define    LED_FLICKERING               0x0E /**< \brief LED flickering*/
-#define    LED_BLINKING                 0x0D /**< \brief LED blinking*/
-#define    LED_SINGLEFLASH              0x01 /**< \brief LED single flash*/
-#define    LED_DOUBLEFLASH              0x02 /**< \brief LED double flash*/
-#define    LED_ON                       0x0F /**< \brief LED on*/
-#define    LED_OVERRIDE                 0x10 /**< \brief LED override (required to force the LED value within the ESC)*/
-#endif
-
-
-#define    MEMORY_START_ADDRESS            0x1000 /**< \brief ESC DPRAM start address*/
-
-
-#ifndef    DC_SYNC_ACTIVE
-    #define    DC_SYNC_ACTIVE                ESC_DC_SYNC0_ACTIVE_MASK /**< \brief Expected activated Sync signals by the master*/
-#endif
-#ifndef    DC_EVENT_MASK
-#if MAX_PD_OUTPUT_SIZE > 0
-    #define    DC_EVENT_MASK                PROCESS_OUTPUT_EVENT /**< \brief AL Event mask (value of register 0x204) in case of DC synchronisation*/
-#else
-    #define    DC_EVENT_MASK                PROCESS_INPUT_EVENT /**< \brief AL Event mask (value of register 0x204) in case of DC synchronisation*/
-#endif
-#endif
-
-
-#endif //_ECATSLV_H_
-
-#if defined(_ECATSLV_) && (_ECATSLV_ == 1)
-    #define PROTO
-#else
-    #define PROTO extern
-#endif
-/*-----------------------------------------------------------------------------------------
-------
-------    Global Variables
-------
------------------------------------------------------------------------------------------*/
-#if BOOTSTRAPMODE_SUPPORTED
-PROTO    BOOL                           bBootMode; /**< \brief Indicates in slave is in BOOT mode*/
-#endif
-PROTO    BOOL                           bEcatOutputUpdateRunning;  /**< \brief Indicates the OP state, will be set in StartOutputHandler
-                                                                                and reset in StopOutputHandler*/
-
-PROTO    BOOL                            bEcatInputUpdateRunning;  /**< \brief Indicates the SAFEOP or OP state, will be set in StartInputHandler
-                                                                                and reset in Stop InputHandler*/
-
-#if MAX_PD_OUTPUT_SIZE > 0
-PROTO    BOOL                           bEcatFirstOutputsReceived; /**< \brief Indicates if outputs were received (SM2-event)
-                                                                                or inputs were read (SM3-event, if the output size is 0),
-                                                                                has to be set by the application and reset in StopOutputHandler*/
-
-PROTO    BOOL                           bWdTrigger; /**< \brief Indicates that the SM2 WD trigger bit (0x814 bit6) is set.*/
-#endif
-
-PROTO    BOOL                           bDcSyncActive; /**< \brief Indicates that the Distributed Clocks synchronization is active,*/
-
-PROTO    INT16                          EsmTimeoutCounter; /**< \brief Counter used to detect an ESM timeout.
-                                                           -1 indicates a deactivated counter and 0 is expired*/
-
-#define MAX_SM_EVENT_MISSED             0xFF /**< \brief threshold of max missed counter value (0x1C32.11 / 0x1C33.11)*/
-
-#if DC_SUPPORTED
-PROTO BOOL                              bDcRunning; /**< \brief Indicates if Sync0 events are received*/
-
-PROTO UINT16                            u16SmSync0Counter; /**< /brief Incremented by one on every Sync0 event and reset to 0 on every SM event. It is used to check the SM/Sync0 sequence */
-PROTO UINT16                            u16SmSync0Value; /**< /brief Allowed Sync0 events within one SM cycle. If 0 the Sequence check is disabled */
-
-PROTO BOOL                              bSmSyncSequenceValid; /**< \brief Set to true if SM/Sync0 sequence is valid*/
-
-PROTO INT16                             i16WaitForPllRunningTimeout; /**< \brief The time bPllRunnig shall be true while state change from SafeOp to Op*/
-
-PROTO INT16                             i16WaitForPllRunningCnt; /**< \brief Incremented with every valid Sync-SyncManger cycle */
-
-PROTO UINT16                            Sync0WdCounter; /**< \brief Sync0 watchdog counter*/
-PROTO UINT16                            Sync0WdValue; /**< \brief Sync0 watchdog value*/
-
-PROTO UINT16                            Sync1WdCounter; /**< \brief Sync1 watchdog counter*/
-PROTO UINT16                            Sync1WdValue; /**< \brief Sync1 watchdog value*/
-
-PROTO UINT16                            LatchInputSync0Value; /**< \brief Sync0 event on which the inputs shall be latched and copied to the ESC buffer. If the inputs shall be latched base don Sync1 the value is set to 0.*/
-PROTO UINT16                            LatchInputSync0Counter; /**< \brief Sync0 counter used to get the Sync0 event to latch the Inputs. */
-
-/*ECATCHANGE_START(V5.12) COE4*/
-PROTO BOOL b32BitDc;
-/*ECATCHANGE_END(V5.12) COE4*/
-#endif
-
-#if !COE_SUPPORTED
-PROTO UINT16    u16SmEventMissedCounter;  /**< \brief Required for Sync0/SM sequence watchdog (if COE_SUPPORTED the value is stored in the object 0x1C32)*/
-#endif
-
-
-PROTO BOOL                              bEscIntEnabled; /**< \brief Indicates that the ESC interrupt is enabled (SM2/3 or SYNC0/1-event),
-                                                                     will be set in StartInputHandler and reset in StopInputHandler*/
-
-PROTO BOOL                              b3BufferMode; /**< \brief Indicates that inputs and outputs are running in 3-Buffer-Mode*/
-
-PROTO BOOL                              bLocalErrorFlag; /**< \brief Contains the information if the application has a local error*/
-PROTO UINT16                            u16LocalErrorCode; /**< \brief Reason for local error*/
-PROTO BOOL                              bApplEsmPending; /**< \brief Indicates if the local application ESM function need to be called from Al_ConntrolRes (is true if NOERR_INWORK is returned by generic ESM function)*/
-PROTO BOOL                              bEcatWaitForAlControlRes; /**< \brief Contains the information that the state machine waits for an acknowledge
-                                                                             for the last AL_ControlInd from the application/generic stack*/
-
-PROTO UINT16                            nEcatStateTrans; /**< \brief Current state transition*/
-
-#if UC_SET_ECAT_LED || ESC_SUPPORT_ECAT_LED
-PROTO UINT8                             u8EcatErrorLed; /**< \brief Current value of the error LED*/
-
-PROTO UINT8                             u8EcatRunLed; /**< \brief Current value of the run LED*/
-#endif
-
-PROTO UINT16                            nPdInputSize; /**< \brief Contains the input size (SM3 size)/SM2 if no outputs are supported, has to be written by the application*/
-
-PROTO UINT16                            nPdOutputSize; /**< \brief Contains the output size (SM2 size), has to be written by the application*/
-
-PROTO UINT8                             nMaxSyncMan; /**< \brief Contains the maximum number of Sync Manager channels, will be initialized in ECAT_Main*/
-
-PROTO UINT16                            nMaxEscAddress; /**< \brief Max supported address by the ESC (register(0x1000) + size of the supported DPRAM in Byte)*/
-
-PROTO UINT8                             nAlStatus; /**< \brief Contains the actual AL Status, will be written in AL_ControlInd*/
-
-#if EXPLICIT_DEVICE_ID
-PROTO BOOL                              bExplicitDevIdRequested; /**< \brief Indicates if 0x0120.5 is set*/
-#endif
-
-PROTO UINT16                            EcatWdValue; /**< \brief Contains the value of the watchdog in ms, will be written in StartInputHandler.
-                                                                    In case that the ESC watchdog feature is used this variable just indicates if the watchdog is enabled or disabled*/
-#if !ESC_SM_WD_SUPPORTED
-PROTO UINT16                            EcatWdCounter; /**< \brief Counter for the watchdog, will be reset in StartInputHandler and from
-                                                                    the application when outputs were received (SM2-event) or inputs were read
-                                                                    (SM3-event, if the output size is 0)*/
-#endif
-#if MAX_PD_OUTPUT_SIZE > 0
-PROTO    UINT16                         nEscAddrOutputData; /**< \brief Contains the SM address for the output process data*/
-#endif
-#if MAX_PD_INPUT_SIZE > 0
-PROTO    UINT16                         nEscAddrInputData; /**< \brief Contains the SM address for the input process data*/
-#endif
-
-
-/*-----------------------------------------------------------------------------------------
-------
-------    Global Functions
-------
------------------------------------------------------------------------------------------*/
-PROTO void EnableSyncManChannel(UINT8 channel);
-PROTO void DisableSyncManChannel(UINT8 channel);
-PROTO TSYNCMAN ESCMEM *GetSyncMan(UINT8 channel);
-PROTO void SetALStatus(UINT8 alStatus, UINT16 alStatusCode);
-PROTO void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode);
-#if !ESC_SM_WD_SUPPORTED
-#if MAX_PD_OUTPUT_SIZE > 0
-PROTO void ECAT_CheckWatchdog(void);
-#endif
-#endif
-#if DC_SUPPORTED
-PROTO void DC_CheckWatchdog(void);
-#endif
-PROTO    void CheckIfEcatError(void);
-PROTO void ECAT_Init(void);
-
-PROTO void ECAT_Main(void);
-
-#undef PROTO
-/** @}*/
+/*
+* This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & Co KG, 33415 Verl, Germany.
+* The corresponding license agreement applies. This hint shall not be removed.
+*/
+
+/**
+ * \addtogroup ESM EtherCAT State Machine
+ * @{
+ */
+
+/**
+\file ecatslv.h
+\author EthercatSSC@beckhoff.com
+
+\version 5.12
+
+<br>Changes to version V5.11:<br>
+V5.12 COE4: add timestamp object (0x10F8) and update diagnosis handling<br>
+V5.12 ECAT6: remove mailbox SyncManager if no mailbox is supported (SM0 Output, SM1 Input)<br>
+<br>Changes to version V5.10:<br>
+V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
+V5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
+V5.11 ECAT9: add new AL Status Codes (ALSTATUSCODE_FW_SII_NOT_MATCH/0x0006, ALSTATUSCODE_FW_UPDATE_FAILED / 0x0007)<br>
+V5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 (SM2 sync)"<br>
+V5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManChannel()"", ""HW_GetSyncMan()"", ""HW_ResetALEventMask()"", ""HW_SetALEventMask()"" to ecatalv.c"<br>
+<br>Changes to version V5.01:<br>
+V5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 to UINT16 (according ETG.1020)<br>
+V5.10 ECAT12: Add new AL Status Codes (0x2E,0x52,0x70)<br>
+V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
+              Compare DC UINT configuration (by ESC Config data) vs. DC activation register settings<br>
+              Update 0x1C3x entries<br>
+<br>Changes to version - :<br>
+V5.01 : Start file change log
+ */
+
+/*-----------------------------------------------------------------------------------------
+------
+------    Includes
+------
+-----------------------------------------------------------------------------------------*/
+
+#include "ecat_def.h"
+
+#if EL9800_HW
+#include "el9800hw.h"
+#elif FC1100_HW
+#include "fc1100hw.h"
+#elif MCI_HW
+#include "mcihw.h"
+#elif KUNBUS_STACK_APPLICATION
+#include  "esc.h"
+#include <ssc_kbStack.h>
+#else
+#include  "esc.h"
+/*CODE_INSERT_START (HW_ACCESS_FILE)*/
+#error Shall not be used !!!
+#include "tieschw.h"
+/*CODE_INSERT_END*/
+#endif
+
+#ifndef _ECATSLV_H_
+#define _ECATSLV_H_
+
+
+/*-----------------------------------------------------------------------------------------
+------
+------    Defines and Types
+------
+-----------------------------------------------------------------------------------------*/
+
+#ifndef OBJGETNEXTSTR
+    /* the old definition was not working with all compilers */
+    /* old:    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )( ((UINT32) p) + OBJSTRLEN( (OBJCONST CHAR OBJMEM *) p ) + 1 ) ) */
+    #define    OBJGETNEXTSTR(p)    ( (OBJCONST CHAR OBJMEM * )(  &((p)[OBJSTRLEN( (OBJCONST CHAR OBJMEM *) (p) ) + 1]) ) ) /**< \brief Macro to get next name within the objetc name string*/
+#endif
+
+#if BIG_ENDIAN_FORMAT
+#ifndef LO_BYTE
+    #define    LO_BYTE                            1 /**< \brief LowByte within an WORD*/
+#endif
+
+#ifndef HI_BYTE
+    #define    HI_BYTE                            0 /**< \brief HighByte within an WORD*/
+#endif
+
+#ifndef LOLO_BYTE
+    #define    LOLO_BYTE                          3 /**< \brief LowLowByte within an DWORD*/
+#endif
+
+#ifndef LOHI_BYTE
+    #define    LOHI_BYTE                          2 /**< \brief LowHighByte within an DWORD*/
+#endif
+
+#ifndef HILO_BYTE
+    #define    HILO_BYTE                         1 /**< \brief HighLowByte within an DWORD*/
+#endif
+
+#ifndef HIHI_BYTE
+    #define    HIHI_BYTE                          0 /**< \brief HighHighByte within an DWORD*/
+#endif
+
+#ifndef LO_WORD
+    #define    LO_WORD                            1 /**< \brief LowWord within an DWORD*/
+#endif
+
+#ifndef HI_WORD
+    #define    HI_WORD                            0 /**< \brief HighWord within an DWORD*/
+#endif
+
+#ifndef SWAPWORD
+    #define    SWAPWORD(x)                        ((UINT16)(((((UINT16)(x))&0xFF)<<8)+((((UINT16)(x))&0xFF00)>>8))) /**< \brief Macro to swap a WORD*/
+#endif
+
+#ifndef SWAPDWORD
+    #define    SWAPDWORD(x)                    ((UINT32)(((((UINT32)(x))&0xFF)<<24)+((((UINT32)(x))&0xFF00)<<8)+((((UINT32)(x))&0xFF0000)>>8)+((((UINT32)(x))&0xFF000000)>>24))) /**< \brief Macro to swap a DWORD*/
+#endif
+#else
+#ifndef LO_BYTE
+    #define    LO_BYTE                            0 /**< \brief LowByte within an WORD*/
+#endif
+
+#ifndef HI_BYTE
+    #define    HI_BYTE                            1 /**< \brief HighByte within an WORD*/
+#endif
+
+#ifndef LOLO_BYTE
+    #define    LOLO_BYTE                          0 /**< \brief LowLowByte within an DWORD*/
+#endif
+
+#ifndef LOHI_BYTE
+    #define    LOHI_BYTE                          1 /**< \brief LowHighByte within an DWORD*/
+#endif
+
+#ifndef HILO_BYTE
+    #define    HILO_BYTE                         2 /**< \brief HighLowByte within an DWORD*/
+#endif
+
+#ifndef HIHI_BYTE
+    #define    HIHI_BYTE                          3 /**< \brief HighHighByte within an DWORD*/
+#endif
+
+#ifndef LO_WORD
+    #define    LO_WORD                            0 /**< \brief LowWord within an DWORD*/
+#endif
+
+#ifndef HI_WORD
+    #define    HI_WORD                            1 /**< \brief HighWord within an DWORD*/
+#endif
+
+#ifndef SWAPWORD
+    #define    SWAPWORD(x)                        (x) /**< \brief Macro to swap a WORD*/
+#endif
+
+#ifndef SWAPDWORD
+    #define    SWAPDWORD(x)                     (x) /**< \brief Macro to swap a DWORD*/
+#endif
+#endif //BIG_ENDIAN_FORMAT
+
+#ifndef LOBYTE
+    #define    LOBYTE(x)                        ((x)&0xFF) /**< \brief LowByte mask*/
+#endif
+
+#ifndef HIBYTE
+    #define    HIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief HighwByte mask*/
+#endif
+
+#ifndef LOLOBYTE
+    #define    LOLOBYTE(x)                        ((x)&0xFF)/**< \brief LowLowByte mask*/
+#endif
+
+#ifndef LOHIBYTE
+    #define    LOHIBYTE(x)                        (((x)&0xFF00)>>8)/**< \brief LowHighByte mask*/
+#endif
+
+#ifndef HILOBYTE
+    #define    HILOBYTE(x)                        (((x)&0xFF0000)>>16)/**< \brief HighLowByte mask*/
+#endif
+
+#ifndef HIHIBYTE
+    #define    HIHIBYTE(x)                        (((x)&0xFF000000)>>24)/**< \brief HighHighByte mask*/
+#endif
+
+#ifndef LOWORD
+    #define    LOWORD(x)                        ((x)&0xFFFF)/**< \brief LowWord mask*/
+#endif
+
+#ifndef HIWORD
+    #define    HIWORD(x)                        (((x)&0xFFFF0000)>>16)/**< \brief HighByte mask*/
+#endif
+
+#ifndef BIT2BYTE
+    #define    BIT2BYTE(x)        (((x)+7)>>3) /**< \brief Marco to convert Bit size to Byte size (round up)*/
+#endif
+
+#ifndef BYTE2BIT
+    #define    BYTE2BIT(x)        ((x)<<3) /**< \brief Marco to convert Byte size to Bit size*/
+#endif
+
+#ifndef BIT2WORD
+    #define    BIT2WORD(x)        (((x)+15)>>4) /**< \brief Marco to convert Bit size to Word size (round up)*/
+#endif
+
+#ifndef BYTE2WORD
+    #define    BYTE2WORD(x)    (((x)+1)>>1) /**< \brief Marco to convert Bytes size to Word size (round up)*/
+#endif
+
+#ifndef ROUNDUPBYTE2WORD
+    #define    ROUNDUPBYTE2WORD(x)    ((((x)+1)>>1)<<1) /**< \brief Round up Byte size to even number of Words*/
+#endif
+
+
+/*---------------------------------------------
+-    State defines
+-----------------------------------------------*/
+#define     STATE_INIT                        ((UINT8) 0x01) /**< \brief State INIT*/
+#define     STATE_PREOP                       ((UINT8) 0x02) /**< \brief State PreOP*/
+#define     STATE_BOOT                        ((UINT8) 0x03) /**< \brief State BOOT*/
+#define     STATE_SAFEOP                      ((UINT8) 0x04) /**< \brief State SafeOP*/
+#define     STATE_OP                          ((UINT8) 0x08) /**< \brief State OP*/
+
+#define     STATE_MASK                        ((UINT8) 0x0F) /**< \brief State mask*/
+#define     STATE_CHANGE                      ((UINT8) 0x10) /**< \brief State change (Error indication/acknowledge) mask and value*/
+#define     STATE_DEVID                       ((UINT8) 0x20) /**< \brief Request/response Explicit device ID*/
+
+#define     BOOT_2_INIT                       ((UINT8)((STATE_BOOT) << 4) | (STATE_INIT)) /**< \brief State transition BOOT to INIT*/
+#define     BOOT_2_PREOP                      ((UINT8)((STATE_BOOT) << 4) | (STATE_PREOP)) /**< \brief State transition BOOT to INIT*/
+#define     BOOT_2_SAFEOP                     ((UINT8)((STATE_BOOT) << 4) | (STATE_SAFEOP)) /**< \brief State transition BOOT to INIT*/
+#define     BOOT_2_OP                         ((UINT8)((STATE_BOOT) << 4) | (STATE_OP)) /**< \brief State transition BOOT to INIT*/
+
+#define     INIT_2_BOOT                       ((UINT8)((STATE_INIT) << 4) | (STATE_BOOT)) /**< \brief State transition INIT to BOOT*/
+#define     PREOP_2_BOOT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_BOOT)) /**< \brief State transition PREOP to BOOT*/
+#define     SAFEOP_2_BOOT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_BOOT)) /**< \brief State transition SAFEOP to BOOT*/
+#define     OP_2_BOOT                         ((UINT8)((STATE_OP) << 4) | (STATE_BOOT)) /**< \brief State transition OP to BOOT*/
+
+#define     INIT_2_INIT                       ((UINT8)((STATE_INIT) << 4) | (STATE_INIT)) /**< \brief State transition INIT to INIT*/
+#define     INIT_2_PREOP                      ((UINT8)((STATE_INIT) << 4) | (STATE_PREOP)) /**< \brief State transition INIT to PREOP*/
+#define     INIT_2_SAFEOP                     ((UINT8)((STATE_INIT) << 4) | (STATE_SAFEOP)) /**< \brief State transition INIT to SAFEOP*/
+#define     INIT_2_OP                         ((UINT8)((STATE_INIT) << 4) | (STATE_OP)) /**< \brief State transition INIT to OP*/
+
+#define     PREOP_2_INIT                      ((UINT8)((STATE_PREOP) << 4) | (STATE_INIT)) /**< \brief State transition PREOP to INIT*/
+#define     PREOP_2_PREOP                     ((UINT8)((STATE_PREOP) << 4) | (STATE_PREOP)) /**< \brief State transition PREOP to PREOP*/
+#define     PREOP_2_SAFEOP                    ((UINT8)((STATE_PREOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition PREOP to SAFEOP*/
+#define     PREOP_2_OP                        ((UINT8)((STATE_PREOP) << 4) | (STATE_OP)) /**< \brief State transition PREOP to OP*/
+
+#define     SAFEOP_2_INIT                     ((UINT8)((STATE_SAFEOP) << 4) | (STATE_INIT)) /**< \brief State transition SAFEOP to INIT*/
+#define     SAFEOP_2_PREOP                    ((UINT8)((STATE_SAFEOP) << 4) | (STATE_PREOP)) /**< \brief State transition SAFEOP to PREOP*/
+#define     SAFEOP_2_SAFEOP                   ((UINT8)((STATE_SAFEOP) << 4) | (STATE_SAFEOP)) /**< \brief State transition SAFEOP to SAFEOP*/
+#define     SAFEOP_2_OP                       ((UINT8)((STATE_SAFEOP) << 4) |( STATE_OP)) /**< \brief State transition SAFEOP to OP*/
+
+#define     OP_2_INIT                         ((UINT8)((STATE_OP) << 4) | (STATE_INIT)) /**< \brief State transition OP to INIT*/
+#define     OP_2_PREOP                        ((UINT8)((STATE_OP) << 4) | (STATE_PREOP)) /**< \brief State transition OP to PREOP*/
+#define     OP_2_SAFEOP                       ((UINT8)((STATE_OP) << 4) | (STATE_SAFEOP)) /**< \brief State transition OP to SAFEOP*/
+#define     OP_2_OP                           ((UINT8)((STATE_OP) << 4) | (STATE_OP)) /**< \brief State transition OP to OP*/
+
+
+/*-------------------------------------------------------------------------------------------------------------------------
+
+ ESM transition error codes
+
+*/
+
+#define    SYNCMANCHODDADDRESS                                     0x00 /**< \brief Emergency and Diagnosis code for an odd SyncManager address*/
+#define    SYNCMANCHADDRESS                                         0x01 /**< \brief Emergency and Diagnosis code for an invalid SyncManager address*/
+#define    SYNCMANCHSIZE                                            0x02 /**< \brief Emergency and Diagnosis code for an invalid  SyncManager size*/
+#define    SYNCMANCHSETTINGS                                        0x03 /**< \brief Emergency and Diagnosis code for an invalid SyncManager settings*/
+#define    ERROR_SYNCMANCH(code, channel)                    ((code)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
+#define    ERROR_SYNCMANCHODDADDRESS(channel)                ((SYNCMANCHODDADDRESS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
+#define    ERROR_SYNCMANCHADDRESS(channel)                    ((SYNCMANCHADDRESS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
+#define    ERROR_SYNCMANCHSIZE(channel)                          ((SYNCMANCHSIZE)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
+#define    ERROR_SYNCMANCHSETTINGS(channel)                    ((SYNCMANCHSETTINGS)+((channel)<<2)) /**< \brief Marco to add SyncManager channel*/
+#define    ERROR_SYNCTYPES                                        0x80 /**< \brief Emergency and Diagnosis code for an invalid Sync types*/
+#define    ERROR_DCSYNCCONTROL                                    0x81 /**< \brief Emergency and Diagnosis code for an invalid DC Sync control*/
+#define    ERROR_DCSYNC0CYCLETIME                                0x82 /**< \brief Emergency and Diagnosis code for an invalid Sync0 cycle time*/
+#define    ERROR_DCSYNC1CYCLETIME                                0x83 /**< \brief Emergency and Diagnosis code for an invalid Sync1 cycle time*/
+#define    ERROR_DCCYCLEPARAMETER                                0x84 /**< \brief Emergency and Diagnosis code for an invalid Cycle parameter*/
+#define    ERROR_DCLATCHCONTROL                                    0x85 /**< \brief Emergency and Diagnosis code for an invalid Latch control*/
+
+#define    ERROR_INVALIDSTATE                                    0xF0 /**< \brief Emergency and Diagnosis code for an invalid State*/
+#define    ERROR_NOMEMORY                                            0xF1 /**< \brief Emergency and Diagnosis code for no memory*/
+#define    ERROR_OBJECTDICTIONARY                                0xF2 /**< \brief Emergency and Diagnosis code for generic object dictionary error*/
+#define    ERROR_NOSYNCMANACCESS                                0xF3 /**< \brief Emergency and Diagnosis code for no SyncManager access*/
+#define    ERROR_NOOFRXPDOS                                        0xF4 /**< \brief Emergency and Diagnosis code for no RxPDOs*/
+#define    ERROR_NOOFTXPDOS                                        0xF5 /**< \brief Emergency and Diagnosis code for no TxPDOs*/
+#define    ERROR_STATECHANGE                                        0xF6 /**< \brief Emergency and Diagnosis code state change error*/
+
+#define    NOERROR_NOSTATECHANGE                                0xFE /**< \brief Indicates no state change*/
+#define    NOERROR_INWORK                                            0xFF /**< \brief Indication for no error but operation is pending*/
+
+#define    EMCY_SM_ERRORCODE                                        0xA000 /**< \brief Emergency and Diagnosis code for an SyncManager error*/
+#define    EMCY_SM_DEVICESPECIFIC                                0xFF00 /**< \brief Emergency and Diagnosis code for a device specific error*/
+
+
+/*---------------------------------------------
+-    AL Status Codes
+-----------------------------------------------*/
+#define    ALSTATUSCODE_NOERROR                        0x0000 /**< \brief No error*/
+#define    ALSTATUSCODE_UNSPECIFIEDERROR               0x0001 /**< \brief Unspecified error*/
+#define    ALSTATUSCODE_NOMEMORY                       0x0002 /**< \brief No Memory*/
+#define    ALSTATUSCODE_INVALID_REVISION               0x0004 /**< \brief Output/Input mapping is not valid for this hardware or software revision (0x1018:03)*/
+#define    ALSTATUSCODE_FW_SII_NOT_MATCH               0x0006 /**< \brief Firmware and EEPROM do not match. Slave needs BOOT-INIT transition*/
+#define    ALSTATUSCODE_FW_UPDATE_FAILED               0x0007 /**< \brief Firmware update not successful. Old firmware still running*/
+#define    ALSTATUSCODE_INVALIDALCONTROL               0x0011 /**< \brief Invalid requested state change*/
+#define    ALSTATUSCODE_UNKNOWNALCONTROL               0x0012 /**< \brief Unknown requested state*/
+#define    ALSTATUSCODE_BOOTNOTSUPP                    0x0013 /**< \brief Bootstrap not supported*/
+#define    ALSTATUSCODE_NOVALIDFIRMWARE                0x0014 /**< \brief No valid firmware*/
+#define    ALSTATUSCODE_INVALIDMBXCFGINBOOT            0x0015 /**< \brief Invalid mailbox configuration (BOOT state)*/
+#define    ALSTATUSCODE_INVALIDMBXCFGINPREOP           0x0016 /**< \brief Invalid mailbox configuration (PreOP state)*/
+#define    ALSTATUSCODE_INVALIDSMCFG                   0x0017 /**< \brief Invalid sync manager configuration*/
+#define    ALSTATUSCODE_NOVALIDINPUTS                  0x0018 /**< \brief No valid inputs available*/
+#define    ALSTATUSCODE_NOVALIDOUTPUTS                 0x0019 /**< \brief No valid outputs*/
+#define    ALSTATUSCODE_SYNCERROR                      0x001A /**< \brief Synchronization error*/
+#define    ALSTATUSCODE_SMWATCHDOG                     0x001B /**< \brief Sync manager watchdog*/
+#define    ALSTATUSCODE_SYNCTYPESNOTCOMPATIBLE         0x001C /**< \brief Invalid Sync Manager Types*/
+#define    ALSTATUSCODE_INVALIDSMOUTCFG                0x001D /**< \brief Invalid Output Configuration*/
+#define    ALSTATUSCODE_INVALIDSMINCFG                 0x001E /**< \brief Invalid Input Configuration*/
+#define    ALSTATUSCODE_INVALIDWDCFG                   0x001F /**< \brief Invalid Watchdog Configuration*/
+#define    ALSTATUSCODE_WAITFORCOLDSTART               0x0020 /**< \brief Slave needs cold start*/
+#define    ALSTATUSCODE_WAITFORINIT                    0x0021 /**< \brief Slave needs INIT*/
+#define    ALSTATUSCODE_WAITFORPREOP                   0x0022 /**< \brief Slave needs PREOP*/
+#define    ALSTATUSCODE_WAITFORSAFEOP                  0x0023 /**< \brief Slave needs SAFEOP*/
+#define    ALSTATUSCODE_INVALIDINPUTMAPPING            0x0024 /**< \brief Invalid Input Mapping*/
+#define    ALSTATUSCODE_INVALIDOUTPUTMAPPING           0x0025 /**< \brief Invalid Output Mapping*/
+#define    ALSTATUSCODE_INCONSISTENTSETTINGS           0x0026 /**< \brief Inconsistent Settings*/
+#define    ALSTATUSCODE_FREERUNNOTSUPPORTED            0x0027 /**< \brief FreeRun not supported*/
+#define    ALSTATUSCODE_SYNCHRONNOTSUPPORTED           0x0028 /**< \brief SyncMode not supported*/
+#define    ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE        0x0029 /**< \brief FreeRun needs 3Buffer Mode*/
+#define    ALSTATUSCODE_BACKGROUNDWATCHDOG             0x002A /**< \brief Background Watchdog*/
+#define    ALSTATUSCODE_NOVALIDINPUTSANDOUTPUTS        0x002B /**< \brief No Valid Inputs and Outputs*/
+#define    ALSTATUSCODE_FATALSYNCERROR                 0x002C /**< \brief Fatal Sync Error*/
+#define    ALSTATUSCODE_NOSYNCERROR                    0x002D /**< \brief No Sync Error*/
+#define    ALSTATUSCODE_CYCLETIMETOOSMALL              0x002E /**< \brief EtherCAT cycle time smaller Minimum Cycle Time supported by slave*/
+#define    ALSTATUSCODE_DCINVALIDSYNCCFG               0x0030 /**< \brief Invalid DC SYNCH Configuration*/
+#define    ALSTATUSCODE_DCINVALIDLATCHCFG              0x0031 /**< \brief Invalid DC Latch Configuration*/
+#define    ALSTATUSCODE_DCPLLSYNCERROR                 0x0032 /**< \brief PLL Error*/
+#define    ALSTATUSCODE_DCSYNCIOERROR                  0x0033 /**< \brief DC Sync IO Error*/
+#define    ALSTATUSCODE_DCSYNCMISSEDERROR              0x0034 /**< \brief DC Sync Timeout Error*/
+#define    ALSTATUSCODE_DCINVALIDSYNCCYCLETIME         0x0035 /**< \brief DC Invalid Sync Cycle Time*/
+#define    ALSTATUSCODE_DCSYNC0CYCLETIME               0x0036 /**< \brief DC Sync0 Cycle Time*/
+#define    ALSTATUSCODE_DCSYNC1CYCLETIME               0x0037 /**< \brief DC Sync1 Cycle Time*/
+#define    ALSTATUSCODE_MBX_AOE                        0x0041 /**< \brief MBX_AOE*/
+#define    ALSTATUSCODE_MBX_EOE                        0x0042 /**< \brief MBX_EOE*/
+#define    ALSTATUSCODE_MBX_COE                        0x0043 /**< \brief MBX_COE*/
+#define    ALSTATUSCODE_MBX_FOE                        0x0044 /**< \brief MBX_FOE*/
+#define    ALSTATUSCODE_MBX_SOE                        0x0045 /**< \brief MBX_SOE*/
+#define    ALSTATUSCODE_MBX_VOE                        0x004F /**< \brief MBX_VOE*/
+#define    ALSTATUSCODE_EE_NOACCESS                    0x0050 /**< \brief EEPROM no access*/
+#define    ALSTATUSCODE_EE_ERROR                       0x0051 /**< \brief EEPROM Error*/
+#define    ALSTATUSCODE_EXT_HARDWARE_NOT_READY         0x0052 /**< \brief External hardware not ready. This AL Status Code should be used if the EtherCAT-Slave refused the state transition due to an external connection to another device or signal is missing*/
+#define    ALSTATUSCODE_DEVICE_IDENT_VALUE_UPDATED     0x0061 /**< \brief In legacy identification mode (dip switch mapped to register 0x12) this error is returned if the EEPROM ID value does not match to dipswitch value*/
+#define    ALSTATUSCODE_MODULE_ID_LIST_NOT_MATCH       0x0070 /**< \brief Detected Module Ident List (0xF030) and Configured Module Ident List (0xF050) does not match*/
+#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_LOW         0x0080 /**< \brief The slave supply voltage is too low*/
+#define    ALSTATUSCODE_SUPPLY_VOLTAGE_TOO_HIGH        0x0081 /**< \brief The slave supply voltage is too high*/
+#define    ALSTATUSCODE_TEMPERATURE_TOO_LOW            0x0080 /**< \brief The slave temperature is too low*/
+#define    ALSTATUSCODE_TEMPERATURE_TOO_HIGH           0x0081 /**< \brief The slave temperature is too high*/
+
+
+
+/*---------------------------------------------
+-    Configured Sync Type (0x1C32.1 / 0x1C33.1)
+-----------------------------------------------*/
+#define     SYNCTYPE_FREERUN            0x0000 /**< \brief Sync type FreeRun*/
+#define     SYNCTYPE_SM_SYNCHRON        0x0001 /**< \brief SyncManager synchron (synchron to the corresponding SM, 0x1C32.1 -> SM2 ; 0x1C33.1 -> SM3)  */
+#define     SYNCTYPE_SM2_SYNCHRON       0x0022 /**< \brief SyncManager2 synchron (only used for 0x1C33.1)*/
+#define     SYNCTYPE_DCSYNC0            0x0002 /**< \brief Sync type Sync0 synchron*/
+#define     SYNCTYPE_DCSYNC1            0x0003 /**< \brief Sync type Sync1 synchron*/
+
+
+/*---------------------------------------------
+-    AL Event masks
+-----------------------------------------------*/
+#define     AL_CONTROL_EVENT                    ((UINT16) 0x01) /**< \brief AL Control event*/
+#define     SYNC0_EVENT                         ((UINT16) 0x04) /**< \brief Sync0 event*/
+#define     SYNC1_EVENT                         ((UINT16) 0x08) /**< \brief Sync1 event*/
+#define     SM_CHANGE_EVENT                     ((UINT16) 0x10) /**< \brief SyncManager changed event*/
+#define     EEPROM_CMD_PENDING                  ((UINT16) 0x20) /**< \brief EEPROM command pending*/
+#define     WATCHDOG_EXPIRED_EVENT              ((UINT16) 0x40) /**< \brief Watchdog expired event*/
+
+#if MAILBOX_SUPPORTED
+#define     MAILBOX_WRITE_EVENT                 ((UINT16) 0x0100) /**< \brief MBoxOut write event*/
+#define     MAILBOX_READ_EVENT                  ((UINT16) 0x0200) /**< \brief MBoxIn read event*/
+#define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0400) /**< \brief Output process data write event*/
+#define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0800) /**< \brief Input process data read event*/
+#else
+/*ECATCHANGE_START(V5.12) ECAT6*/
+#define     PROCESS_OUTPUT_EVENT                ((UINT16) 0x0100) /**< \brief Output process data write event*/
+#define     PROCESS_INPUT_EVENT                 ((UINT16) 0x0200) /**< \brief Input process data read event*/
+/*ECATCHANGE_END(V5.12) ECAT6*/
+#endif
+
+#if MAILBOX_SUPPORTED
+#define    MAILBOX_WRITE                        0 /**< \brief SyncManager ID for MBoxOut (master to slave)*/
+#define    MAILBOX_READ                         1 /**< \brief SyncManager ID for MBoxIn (slave to master)*/
+#define    PROCESS_DATA_OUT                     2 /**< \brief SyncManager ID for output process data (master to slave)*/
+#define    PROCESS_DATA_IN                      3 /**< \brief SyncManager ID for input process data (slave to master)*/
+#else
+/*ECATCHANGE_START(V5.12) ECAT6*/
+#define    PROCESS_DATA_OUT                     0 /**< \brief SyncManager ID for output process data (master to slave)*/
+#define    PROCESS_DATA_IN                      1 /**< \brief SyncManager ID for input process data (slave to master)*/
+/*ECATCHANGE_END(V5.12) ECAT6*/
+#endif
+
+
+
+
+#if UC_SET_ECAT_LED
+/*---------------------------------------------
+-     Codes for LED
+      bit 7: invert flag
+      bit 6: toggle    (if toggle == 1 and number of flashes == 0 => infinite toggle)
+      bit 5: fast toggle flag (50ms cycle)
+      bit 4-0: number of flashes
+-----------------------------------------------*/
+#define    LED_OFF                      0x00 /**< \brief LED off*/
+#define    LED_FLICKERING               0x60 /**< \brief LED flickering*/
+#define    LED_BLINKING                 0x40 /**< \brief LED blinking*/
+#define    LED_SINGLEFLASH              0x41 /**< \brief LED single flash*/
+#define    LED_DOUBLEFLASH              0x42 /**< \brief LED double flash*/
+#define    LED_INVERT_DOUBLEFLASH       0xC2 /**< \brief LED invert double flash*/
+#define    LED_ON                       0x01 /**< \brief LED on*/
+
+#elif ESC_SUPPORT_ECAT_LED
+#define    LED_OFF                      0x00 /**< \brief LED off*/
+#define    LED_FLICKERING               0x0E /**< \brief LED flickering*/
+#define    LED_BLINKING                 0x0D /**< \brief LED blinking*/
+#define    LED_SINGLEFLASH              0x01 /**< \brief LED single flash*/
+#define    LED_DOUBLEFLASH              0x02 /**< \brief LED double flash*/
+#define    LED_ON                       0x0F /**< \brief LED on*/
+#define    LED_OVERRIDE                 0x10 /**< \brief LED override (required to force the LED value within the ESC)*/
+#endif
+
+
+#define    MEMORY_START_ADDRESS            0x1000 /**< \brief ESC DPRAM start address*/
+
+
+#ifndef    DC_SYNC_ACTIVE
+    #define    DC_SYNC_ACTIVE                ESC_DC_SYNC0_ACTIVE_MASK /**< \brief Expected activated Sync signals by the master*/
+#endif
+#ifndef    DC_EVENT_MASK
+#if MAX_PD_OUTPUT_SIZE > 0
+    #define    DC_EVENT_MASK                PROCESS_OUTPUT_EVENT /**< \brief AL Event mask (value of register 0x204) in case of DC synchronisation*/
+#else
+    #define    DC_EVENT_MASK                PROCESS_INPUT_EVENT /**< \brief AL Event mask (value of register 0x204) in case of DC synchronisation*/
+#endif
+#endif
+
+
+#endif //_ECATSLV_H_
+
+#if defined(_ECATSLV_) && (_ECATSLV_ == 1)
+    #define PROTO
+#else
+    #define PROTO extern
+#endif
+/*-----------------------------------------------------------------------------------------
+------
+------    Global Variables
+------
+-----------------------------------------------------------------------------------------*/
+#if BOOTSTRAPMODE_SUPPORTED
+PROTO    BOOL                           bBootMode; /**< \brief Indicates in slave is in BOOT mode*/
+#endif
+PROTO    BOOL                           bEcatOutputUpdateRunning;  /**< \brief Indicates the OP state, will be set in StartOutputHandler
+                                                                                and reset in StopOutputHandler*/
+
+PROTO    BOOL                            bEcatInputUpdateRunning;  /**< \brief Indicates the SAFEOP or OP state, will be set in StartInputHandler
+                                                                                and reset in Stop InputHandler*/
+
+#if MAX_PD_OUTPUT_SIZE > 0
+PROTO    BOOL                           bEcatFirstOutputsReceived; /**< \brief Indicates if outputs were received (SM2-event)
+                                                                                or inputs were read (SM3-event, if the output size is 0),
+                                                                                has to be set by the application and reset in StopOutputHandler*/
+
+PROTO    BOOL                           bWdTrigger; /**< \brief Indicates that the SM2 WD trigger bit (0x814 bit6) is set.*/
+#endif
+
+PROTO    BOOL                           bDcSyncActive; /**< \brief Indicates that the Distributed Clocks synchronization is active,*/
+
+PROTO    INT16                          EsmTimeoutCounter; /**< \brief Counter used to detect an ESM timeout.
+                                                           -1 indicates a deactivated counter and 0 is expired*/
+
+#define MAX_SM_EVENT_MISSED             4 /**< \brief threshold of max missed counter value (0x1C32.11 / 0x1C33.11)*/
+
+#if DC_SUPPORTED
+PROTO BOOL                              bDcRunning; /**< \brief Indicates if Sync0 events are received*/
+
+PROTO UINT16                            u16SmSync0Counter; /**< /brief Incremented by one on every Sync0 event and reset to 0 on every SM event. It is used to check the SM/Sync0 sequence */
+PROTO UINT16                            u16SmSync0Value; /**< /brief Allowed Sync0 events within one SM cycle. If 0 the Sequence check is disabled */
+
+PROTO BOOL                              bSmSyncSequenceValid; /**< \brief Set to true if SM/Sync0 sequence is valid*/
+
+PROTO INT16                             i16WaitForPllRunningTimeout; /**< \brief The time bPllRunnig shall be true while state change from SafeOp to Op*/
+
+PROTO INT16                             i16WaitForPllRunningCnt; /**< \brief Incremented with every valid Sync-SyncManger cycle */
+
+PROTO UINT16                            Sync0WdCounter; /**< \brief Sync0 watchdog counter*/
+PROTO UINT16                            Sync0WdValue; /**< \brief Sync0 watchdog value*/
+
+PROTO UINT16                            Sync1WdCounter; /**< \brief Sync1 watchdog counter*/
+PROTO UINT16                            Sync1WdValue; /**< \brief Sync1 watchdog value*/
+
+PROTO UINT16                            LatchInputSync0Value; /**< \brief Sync0 event on which the inputs shall be latched and copied to the ESC buffer. If the inputs shall be latched base don Sync1 the value is set to 0.*/
+PROTO UINT16                            LatchInputSync0Counter; /**< \brief Sync0 counter used to get the Sync0 event to latch the Inputs. */
+
+/*ECATCHANGE_START(V5.12) COE4*/
+PROTO BOOL b32BitDc;
+/*ECATCHANGE_END(V5.12) COE4*/
+#endif
+
+#if !COE_SUPPORTED
+PROTO UINT16    u16SmEventMissedCounter;  /**< \brief Required for Sync0/SM sequence watchdog (if COE_SUPPORTED the value is stored in the object 0x1C32)*/
+#endif
+
+
+PROTO BOOL                              bEscIntEnabled; /**< \brief Indicates that the ESC interrupt is enabled (SM2/3 or SYNC0/1-event),
+                                                                     will be set in StartInputHandler and reset in StopInputHandler*/
+
+PROTO BOOL                              b3BufferMode; /**< \brief Indicates that inputs and outputs are running in 3-Buffer-Mode*/
+
+PROTO BOOL                              bLocalErrorFlag; /**< \brief Contains the information if the application has a local error*/
+PROTO UINT16                            u16LocalErrorCode; /**< \brief Reason for local error*/
+PROTO BOOL                              bApplEsmPending; /**< \brief Indicates if the local application ESM function need to be called from Al_ConntrolRes (is true if NOERR_INWORK is returned by generic ESM function)*/
+PROTO BOOL                              bEcatWaitForAlControlRes; /**< \brief Contains the information that the state machine waits for an acknowledge
+                                                                             for the last AL_ControlInd from the application/generic stack*/
+
+PROTO UINT16                            nEcatStateTrans; /**< \brief Current state transition*/
+
+#if UC_SET_ECAT_LED || ESC_SUPPORT_ECAT_LED
+PROTO UINT8                             u8EcatErrorLed; /**< \brief Current value of the error LED*/
+
+PROTO UINT8                             u8EcatRunLed; /**< \brief Current value of the run LED*/
+#endif
+
+PROTO UINT16                            nPdInputSize; /**< \brief Contains the input size (SM3 size)/SM2 if no outputs are supported, has to be written by the application*/
+
+PROTO UINT16                            nPdOutputSize; /**< \brief Contains the output size (SM2 size), has to be written by the application*/
+
+PROTO UINT8                             nMaxSyncMan; /**< \brief Contains the maximum number of Sync Manager channels, will be initialized in ECAT_Main*/
+
+PROTO UINT16                            nMaxEscAddress; /**< \brief Max supported address by the ESC (register(0x1000) + size of the supported DPRAM in Byte)*/
+
+PROTO UINT8                             nAlStatus; /**< \brief Contains the actual AL Status, will be written in AL_ControlInd*/
+
+#if EXPLICIT_DEVICE_ID
+PROTO BOOL                              bExplicitDevIdRequested; /**< \brief Indicates if 0x0120.5 is set*/
+#endif
+
+PROTO UINT16                            EcatWdValue; /**< \brief Contains the value of the watchdog in ms, will be written in StartInputHandler.
+                                                                    In case that the ESC watchdog feature is used this variable just indicates if the watchdog is enabled or disabled*/
+#if !ESC_SM_WD_SUPPORTED
+PROTO UINT16                            EcatWdCounter; /**< \brief Counter for the watchdog, will be reset in StartInputHandler and from
+                                                                    the application when outputs were received (SM2-event) or inputs were read
+                                                                    (SM3-event, if the output size is 0)*/
+#endif
+#if MAX_PD_OUTPUT_SIZE > 0
+PROTO    UINT16                         nEscAddrOutputData; /**< \brief Contains the SM address for the output process data*/
+#endif
+#if MAX_PD_INPUT_SIZE > 0
+PROTO    UINT16                         nEscAddrInputData; /**< \brief Contains the SM address for the input process data*/
+#endif
+
+
+/*-----------------------------------------------------------------------------------------
+------
+------    Global Functions
+------
+-----------------------------------------------------------------------------------------*/
+PROTO void EnableSyncManChannel(UINT8 channel);
+PROTO void DisableSyncManChannel(UINT8 channel);
+PROTO TSYNCMAN ESCMEM *GetSyncMan(UINT8 channel);
+PROTO void SetALStatus(UINT8 alStatus, UINT16 alStatusCode);
+PROTO void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode);
+#if !ESC_SM_WD_SUPPORTED
+#if MAX_PD_OUTPUT_SIZE > 0
+PROTO void ECAT_CheckWatchdog(void);
+#endif
+#endif
+#if DC_SUPPORTED
+PROTO void DC_CheckWatchdog(void);
+#endif
+PROTO    void CheckIfEcatError(void);
+PROTO void ECAT_Init(void);
+
+PROTO void ECAT_Main(void);
+
+#undef PROTO
+/** @}*/
--
2.25.1


From daf598b0d1f65eeeaa469cdb4c75aa682c3fb966 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Tue, 28 Sep 2021 06:15:15 +0200
Subject: [PATCH 10/11] DTKEC-403 improve comment on MIN_PD_CYCLE_TIME

---
 SlaveFiles/src/ecat_def.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecat_def.h b/SlaveFiles/src/ecat_def.h
index 0c62483..5fb4ed8 100644
--- a/SlaveFiles/src/ecat_def.h
+++ b/SlaveFiles/src/ecat_def.h
@@ -1126,7 +1126,7 @@ MAX_PD_OUTPUT_SIZE: Maximum size of the process output data (Sync Manager 2) for
 MIN_PD_CYCLE_TIME: Minimum cycle time in ns the slave is supporting (entry 0x1C3x:05).<br>
 In case that the value is set to 0 the value of 0x1C3x:5 is calculated if 0x1C3x.8 is 1 */
 #ifndef MIN_PD_CYCLE_TIME
-#define MIN_PD_CYCLE_TIME                         0xC350 /* MIN PD Cycle KB 250usec */ //0x79E0// 31.2us 0x7A120
+#define MIN_PD_CYCLE_TIME                         0xC350 /* MIN PD Cycle KB 50usec = 50000 nsec = 0xc350 */
 #endif

 /**
--
2.25.1


From dfb8ad26ca03084c4ab1377ae3d546a300501d73 Mon Sep 17 00:00:00 2001
From: Andreas Willig <andreas.willig@willig-embedded.de>
Date: Wed, 29 Sep 2021 17:33:37 +0200
Subject: [PATCH 11/11] DTKEC-457 update of hooked function to SSC coding
 convention update

Signed-off-by: Andreas Willig <andreas.willig@willig-embedded.de>
---
 SlaveFiles/src/ecatappl.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/SlaveFiles/src/ecatappl.c b/SlaveFiles/src/ecatappl.c
index 861d887..7abc0af 100644
--- a/SlaveFiles/src/ecatappl.c
+++ b/SlaveFiles/src/ecatappl.c
@@ -1506,7 +1506,7 @@ void MainLoop(void)
          *     HW_ClearTimer;
          * /pseudoC; */

-        ssc_CheckTimer(
+        SSC_checkTimer(
             /* ECAT_CheckTimer */
             bEcatWaitForAlControlRes, &EsmTimeoutCounter,
             /* ECAT_SetLedIndication */
--
2.25.1

