<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PROFINET Device: Compact IO-Device Example Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PROFINET Device
   &#160;<span id="projectnumber">v2.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('compact_device_example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Compact IO-Device Example Project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>The PROFINET example application provides an example of a PROFINET field device (hereinafter called <b>IO-Device</b>) based on the PROFINET IO Stack (hereinafter called <b>PNIO Stack</b>) as part of the TI MCU SDK package. <br  />
 The main goal of the application is to provide the user a basic understanding of how the PNIO Stack can be configured and handled. The example is a good starting point to develop your own IO-device. </p>
<h1><a class="anchor" id="features_overview"></a>
Features Overview</h1>
<p>This example application implements all mandatory features, which are required by the PROFINET Specification for a CC-B IO-device. <br  />
 The main features are described below. </p>
<h2><a class="anchor" id="app_debug_console"></a>
Debug UART Console</h2>
<p>The PROFINET Stack provides a callback Interface to register a printf functionality. Such can be used to integrate a logging mechanism, for example printing the Information provided by the PROFINET Stack via a Serial Port Connection.</p>
<p>Within the provided Example projects, a UART Interface is configured in the SysConfig Settings and results in below generated code in <code>ti_drivers_open_close.c</code> including the declaration of the handle <code>gUartHandle</code> that is later used in the example code to access the UART.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * UART</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* UART Driver handles */</span></div>
<div class="line">UART_Handle gUartHandle[CONFIG_UART_NUM_INSTANCES];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* UART Driver Parameters */</span></div>
<div class="line">UART_Params gUartParams[CONFIG_UART_NUM_INSTANCES] =</div>
<div class="line">{</div>
<div class="line">    {</div>
<div class="line">        .baudRate           = 115200,</div>
<div class="line">        .dataLength         = UART_LEN_8,</div>
<div class="line">        .stopBits           = UART_STOPBITS_1,</div>
<div class="line">        .parityType         = UART_PARITY_NONE,</div>
<div class="line"> </div>
<div class="line">        :</div>
<div class="line">        :</div>
<div class="line">        :</div>
</div><!-- fragment --><p>In the application <code>main</code> (main.c) Task a corresponding callback function is registered by calling <code>OSAL_registerPrintOut</code>. In the callback function strings are then written to the console output by calling <code>UART_write</code> from the Texas Instruments driver library:</p>
<div class="fragment"><div class="line">OSAL_registerPrintOut(NULL, APP_printf);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> APP_printf(<span class="keywordtype">void</span>* pContext_p, <span class="keyword">const</span> <span class="keywordtype">char</span>* __restrict pFormat_p, va_list arg_p)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* @cppcheck_justify{unusedVariable} false-positive: variable is used */</span></div>
<div class="line">    <span class="comment">//cppcheck-suppress unusedVariable</span></div>
<div class="line">    int32_t             transferOK;</div>
<div class="line">    <span class="comment">/* @cppcheck_justify{unusedVariable} false-positive: variable is used */</span></div>
<div class="line">    <span class="comment">//cppcheck-suppress unusedVariable</span></div>
<div class="line">    UART_Transaction    transaction;</div>
<div class="line">    </div>
<div class="line">    OSALUNREF_PARM(pContext_p);</div>
<div class="line">    </div>
<div class="line">    UART_Transaction_init(&amp;transaction);</div>
<div class="line">    </div>
<div class="line">    memset(aOutStream_s, 0, <span class="keyword">sizeof</span>(aOutStream_s));</div>
<div class="line">    (void)vsnprintf(aOutStream_s, <span class="keyword">sizeof</span>(aOutStream_s), pFormat_p, arg_p);</div>
<div class="line">    </div>
<div class="line">    transaction.count   = strlen(aOutStream_s);</div>
<div class="line">    transaction.buf     = (<span class="keywordtype">void</span> *)aOutStream_s;</div>
<div class="line">    transaction.args    = NULL;</div>
<div class="line">    transferOK = UART_write(gUartHandle[CONFIG_UART_CONSOLE], &amp;transaction);</div>
<div class="line">    </div>
<div class="line">    (void)transferOK;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The function registered will then be called, when either Stack or Application will call an OSAL_printf().</p>
<div class="fragment"><div class="line">OSAL_printf (<span class="stringliteral">&quot;\r[APP] INFO: Configuring and starting PROFINET stack...\n&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="leds"></a>
LEDs</h2>
<p>There are some LEDs on the evaluation board which are controlled by the LED task in this example programme and used in the following way: </p><table class="doxtable">
<tr>
<th><b>SysConfig</b>  </th><th><b>Color</b>  </th><th><b>AM64x_AM243x EVM</b>  </th><th><b>AM243x LP</b>  </th><th><b>Description</b>   </th></tr>
<tr>
<td>CONFIG_SYS_FAILURE_LED  </td><td>red  </td><td>LD23 (TEST_LED1)  </td><td>LD2 (TEST_LED2_RED)  </td><td>Indicates system failure. For example in case of no cyclic communication with PROFINET IO Controller.   </td></tr>
<tr>
<td>CONFIG_DCP_SIGNAL_LED  </td><td>green  </td><td>LD26 (TEST_LED2)  </td><td>LD1 (TEST_LED1_GREEN)  </td><td>Indicates receive of "DCP signal".   </td></tr>
<tr>
<td>CONFIG_CYCLIC_LEDS  </td><td>green  </td><td>LD11…LD14<br  />
LD16...LD19  </td><td>LD12…LD15  </td><td>Represent the first byte of the output process data received cyclically from the controller.<br  />
 If there are only 4 LEDs it's the low nibble of the first byte.   </td></tr>
</table>
<h2><a class="anchor" id="communication_status_indication"></a>
Communication status indication</h2>
<p>The system failure LED (CONFIG_SYS_FAILURE_LED) is used to indicate the communication status. This LED is flashing in case of no PROFINET communication and continuously OFF in case the communication has been established successfully. </p>
<h2><a class="anchor" id="dcp_signal_indication"></a>
DCP Signal indication</h2>
<p>The DCP Signal is used to identify a single PROFINET device (IO-device or IO-controller) by blinking a LED. If a DCP Signal was sent to the IO-device on the PROFINET network, the PNIO stack indicates the start of DCP Signal to the application. The Application starts blinking the DCP Signal (LED CONFIG_DCP_SIGNAL_LED) with 1 Hz frequency. After 3 seconds, the stack indicates a stop of the DCP Signal to the application and the Applications stops blinking the DCP Signal LED. </p>
<h2><a class="anchor" id="cyclic_data_communication"></a>
Cyclic data communication (Process Data Inputs/Outputs)</h2>
<p>All I/O submodules are mapped to the input and output process data images respectively. From the IO-device point of view: </p><ul>
<li>
<b>Input</b> data is being sent <b>from IO-Device to IO-Controller</b>. </li>
<li>
<b>Output</b> data is being sent <b>from IO-Controller to IO-Device</b>. </li>
</ul>
<p>The cyclic data exchange starts after the communication with a PROFINET Controller (hereinafter called <b>IO-Controller</b>) is established . </p>
<p><b>Output data</b></p>
<p>The Process data LEDs (CONFIG_CYCLIC_LEDS) reflect the value of the first output byte. Every LED of the process data LED group is associated with a bit of the first output byte. If the value of a particular bit is set to “1” corresponding LED will be switched ON. In case of bit value “0”, appropriate LED will be switched OFF. </p>
<p><b>Input data</b></p>
<p>The first output byte received from the controller is copied to the first input byte.<br  />
Additionally the application increments the second input byte.<br  />
Both actions are performed within the main task periodically. </p>
<h2><a class="anchor" id="acyclic_data_communication"></a>
Acyclic data communication</h2>
<p>In addition to the cyclic data exchange of process input/output data PROFINET uses acyclic data communication to exchange parameter data or network management data between IO-Controller and IO-Devices. The following acyclic data communication is implemented in the example application:</p>
<ul>
<li>
I&amp;M0…I&amp;M4 data: Identification &amp; Maintenance data like device name, location in the factory, maintenance information for a device can be read and written to a device. </li>
<li>
Port Data Check </li>
<li>
Port Data Adjust </li>
<li>
SNMP data: The Simple Network Management Protocol is used together with the Link Layer Discovery Protocol (LLDP) to do neighborhood discovery and network management in PROFINET networks.  </li>
</ul>
<h2><a class="anchor" id="permanent_data_storage"></a>
Permanent data storage</h2>
<p>All relevant IO-device data is stored permanently in the external OSPI flash memory. <br  />
The external EEPROM is used for storing MAC address for the Ethernet Interface of the IO-device. </p>
<h2><a class="anchor" id="factory_reset"></a>
Factory reset</h2>
<p>The application has a separate instance running, which stores the default values of the permanent data. In case of a factory reset the currently stored permanent data will be overwritten with those default values. </p>
<p>The example application supports an original Factory Reset and a Reset to Factory Mode 2 (Reset Communication parameter). </p>
<h1><a class="anchor" id="pnio_stack_api"></a>
PNIO Stack API structure</h1>
<p>The PNIO stack structure is based on the instance model from the PROFINET. </p>
<p><img src="profinet_example_instance_model.png" alt="PROFINET instance model" height="auto" border="1" class="inline"/> </p>
<p><em>Figure 1 - based on the PROFINET instance model from IEC CDV 61158-5-10 - Annex A.</em> </p>
<p>Stack application programming interface (API) functions are grouped in a way to reflect the stack components. The application shall use the API functions to start-up the stack as well as for the run-time interaction. </p>
<h2><a class="anchor" id="pdev"></a>
Physical device (PDEV)</h2>
<p>PDEV component handles data and incorporates services which are relevant for the whole physical device. Use <a class="el" href="_p_n__a_p_i__p_d_e_v-example.html">PN_API_PDEV</a> group to configure chassis id or to start the IO-device for instance. </p>
<h2><a class="anchor" id="dev"></a>
Logical device (DEV)</h2>
<p>DEV component handles data and incorporates services which are relevant for a logical device. According to instance model it is possible to have multiple logical devices as well as controllers on one physical device. Current implementation foresees one logical device. Use <a class="el" href="_p_n__a_p_i__d_e_v-example.html">PN_API_DEV</a> group to plug and pull submodules for instance. </p>
<h2><a class="anchor" id="im"></a>
Identification and maintenance (IM)</h2>
<p>IM component handles the data and incorporates services which are relevant specifically for I&amp;M data. Though logically I&amp;M is a part of the logical device, these APIs were put in a separate <a class="el" href="_p_n__a_p_i__i_m-example.html">PN_API_IM</a> group to make DEV group less bulky. </p>
<h2><a class="anchor" id="eth"></a>
Ethernet interface (ETH)</h2>
<p>ETH component handles data and incorporates services which are relevant for Ethernet interfaces of an IO- device. According to instance model one physical device can have multiple Ethernet interfaces. Current implementation foresees one Ethernet interface. Use <a class="el" href="_p_n__a_p_i__e_t_h-example.html">PN_API_ETH</a> group to configure port data or MAC address for instance. </p>
<h2><a class="anchor" id="snmp"></a>
SNMP</h2>
<p>SNMP component takes care of data and services which are relevant for the SNMP agent of an IO-device. To configure SNMP use <a class="el" href="_p_n__a_p_i__s_n_m_p-example.html">PN_API_SNMP</a> group. </p>
<h2><a class="anchor" id="callbacks"></a>
Callbacks</h2>
<p>In some cases the stack needs to communicate with the application during run-time. It can be an indication of some event, such as factory reset. It can be a data exchange as well, as in the case of storing permanent data to the flash. For these purposes a callback mechanism is used. It is expected, that the application registers relevant callback functions to the stack. Some callback functions are mandatory, some are optional. </p>
<p>Callbacks are synchronous: after calling a callback function the stack is blocked, waiting for the application to finish the execution. Therefore it is an important requirement for the callback functions to be as fast as possible. </p>
<p>Basically two methods are used to register a callback function to the stack. It depends on the API group, which method to use for the callback registration. </p>
<h3><a class="anchor" id="single_callback_registration"></a>
Single callback registration</h3>
<p>The stack provides one specific API function to register a specific callback function. An example of <a class="el" href="group___p_n___a_p_i___d_e_v_ga3a7da1d4334cca7e1cef3ad3b8d5d8f1.html#ga3a7da1d4334cca7e1cef3ad3b8d5d8f1" title="Register IO device callback indicating a write record request has been received.">PN_API_DEV_registerWriteRecordIndicatedCallback()</a> registration is depicted in the figure below. </p>
<p><img src="profinet_example_single_callback.png" alt="Single callback" height="500px" border="1" class="inline"/> </p>
<p><em>Figure 2 - Single callback example.</em> </p>
<h3><a class="anchor" id="callback_vector_registration"></a>
Callback vector registration</h3>
<p>The other way to register callback functions is using the callback vector. Pointers to callback functions are grouped together in a vector and passed to the stack using one API function. For instance all callbacks from ETH API must be registered as vector: instance of the <a class="el" href="struct_p_n___a_p_i___e_t_h___s_callbacks.html">PN_API_ETH_SCallbacks</a>. </p>
<p><img src="profinet_example_callback_vector.png" alt="Callback vector" height="500px" border="1" class="inline"/> </p>
<p><em>Figure 3 - Callback vector example.</em> </p>
<h1><a class="anchor" id="demo_application_architecture"></a>
Demo Application Architecture</h1>
<p>The example application consists of two tasks:</p>
<ul>
<li>
<p class="startli"></p>
<p class="interli">The main task configures hardware, initializes and configures the PNIO stack and creates the LED task. Apart from this, it is responsible for periodical triggering of the stack* and the process data image update; <br  />
*- such implementation has historical reasons. It is planned to make this triggering transparent for the application. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">The LED task is responsible for PROFINET-relevant board LEDs.<br  />
<br  />
 </p>
<p class="endli"></p>
</li>
</ul>
<p><img src="profinet_example_task_model.png" alt="Tasks model of the demo" height="500px" border="1" class="inline"/> </p>
<p><em>Figure 4 - Task model of the demo application.</em> </p>
<h1><a class="anchor" id="application_lifecycle"></a>
Application lifecycle</h1>
<p>The application has two main phases: Startup and Run-Time.</p>
<p>During the startup sequence the application initializes and configures the board and system hardware, starts the operating system and creates tasks. </p>
<p>Regarding the PNIO stack: the application is responsible for initialization and configuration of the stack. From PROFINET point of view this is a point of creation, configuration and start of a PN-device. </p>
<p>After the application has started the IO-device, it is entering the Run-time phase. From now on the IO-device is visible for other PROFINET participants and can start the communication. In the run-time phase the application is responsible for handling the process data as well as responses to occasional callback requests from the stack. The LEDs status update and permanent data operations are being handled here as well. </p>
<p><img src="profinet_example_control_flow.png" alt="Application control flow" height="500px" border="1" class="inline"/> </p>
<p><em>Figure 5 - Application control flow.</em> </p>
<p>In the text below we will focus on the PROFINET-relevant operations executed by the application. </p>
<h1><a class="anchor" id="startup"></a>
Startup</h1>
<p>During the startup sequence the application initializes, configures and starts the IO-device. </p>
<h2><a class="anchor" id="init"></a>
Initialization</h2>
<p>In the main task the application initializes stack and stack-relevant hardware. The <code>APP_initProfinetStack()</code> function is used for this purpose. </p>
<ul>
<li>
<p class="startli"></p>
<p class="interli">Initialize PRU ICSS instance, defined in SysConfig, and load pre-compiled PROFINET-specific firmware to the PRU. In this step the application provides MAC address of the PROFINET interface to the PRU as well. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Initialize permanent storage and read permanent storage data to RAM. Permanent data will be needed in the configuration step. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Initialize stack using <code><a class="el" href="group___p_n___a_p_i___p_d_e_v_gac5fa5c2e1136b90553d1d3b30234e135.html#gac5fa5c2e1136b90553d1d3b30234e135" title="Initialize physical device, ethernet interface, ip stack, and IO device.">PN_API_PDEV_init()</a></code>. This function must be called prior executing any other stack API function. </p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="config"></a>
Configuration</h2>
<p>The application must be properly configured in the PNIO-stack to guarantee a successful operation. The <code>APP_configureProfinetStack()</code> function takes care of the configuration step, in the example application. Assume all functions, described below, are <b>mandatory </b>for configuration of an IO-device if not mentioned otherwise. </p>
<p><img src="profinet_example_config_flow.png" alt="Configuration control flow" height="500px" border="1" class="inline"/> </p>
<p><em>Figure 6 - Configuration control flow diagram.</em> </p>
<h3><a class="anchor" id="physical_device"></a>
Physical device (PDev)</h3>
<p>Main focus of the PDev configuration is to specify chassis id, vendor id and device id of the physical device. There are no relevant callbacks to register here. </p>
<p>APP_configPdev() fills an instance of <a class="el" href="struct_p_n___a_p_i___p_d_e_v___s_configuration.html">PN_API_PDEV_SConfiguration</a> structure with valid values and passes it to the stack using <a class="el" href="group___p_n___a_p_i___p_d_e_v_ga5e3f38687dd90f32940436a66744caea.html#ga5e3f38687dd90f32940436a66744caea" title="Apply configuration of physical device.">PN_API_PDEV_applyConfiguration()</a>. </p>
<p><b>Note: </b>It is not allowed to re-configure PDev after the PROFINET communication has been started. </p>
<h3><a class="anchor" id="ethernet_interface"></a>
Ethernet interface</h3>
<p>In some cases the IO-device is addressed via an Ethernet interface. For instance, the discovery and basic configuration protocol (DCP) assigns the StationName or IP address to an Ethernet interface. Therefore this component shall be explicitly configured by the application. <br  />
The example application executes APP_configEth() to configure such parameters as e.g.: </p>
<ul>
<li>
<p class="startli"></p>
<p class="interli">Station name, IP address;</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Interface MAC address. It must be consistent with MAC address specified for the PRU during initialization; </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Port data (Port 1 and Port 2);</p>
<p class="endli"></p>
</li>
</ul>
<p>Additionally it is important to configure callbacks, which require actions from the application side: </p>
<ul>
<li>
<p class="startli"></p>
<p class="interli">Manipulate permanent data. For example: save interface-relevant permanent data or factory reset; </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Indicate “DCP Signal” LED;</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Provide system time. Is needed by the stack to generate UUIDs;</p>
<p class="endli"></p>
</li>
</ul>
<p>The application fills an instance of the <a class="el" href="struct_p_n___a_p_i___e_t_h___s_configuration.html">PN_API_ETH_SConfiguration</a> structure with valid values and passes it to the stack using <a class="el" href="group___p_n___a_p_i___e_t_h_ga20a816ba6a2947eacb03a4e7c31ef42e.html#ga20a816ba6a2947eacb03a4e7c31ef42e" title="Apply configuration of ethernet interface.">PN_API_ETH_applyConfiguration()</a>. </p>
<h3><a class="anchor" id="snmp_agent"></a>
SNMP agent</h3>
<p>Similar as for the Ethernet interface, the application must configure the SNMP agent of an IO-device. The APP_configSnmp() function is responsible for this. </p>
<h3><a class="anchor" id="logical_device_im_data"></a>
Logical device / I&amp;M data</h3>
<p>As mentioned before, I&amp;M data is a part of the logical device. I&amp;M APIs have been separated to unload the DEV APIs. Therefore the I&amp;M and device configuration will be described in this section together. </p>
<p><img src="profinet_example_dev_config_flow.png" alt="Logical device configuration control flow" height="800px" border="1" class="inline"/> </p>
<p><em>Figure 7 - Logical device configuration.</em> </p>
<ul>
<li>
<p class="startli"></p>
<p class="interli">The configuration of the logical IO-device happens in <code>APP_configDev()</code>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">The configuration order, depicted in the figure above, is important! </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Submodules must be mapped to I/O data buffers.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">Therefore the data buffers must be set prior plugging submodules.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">On the other hand I&amp;M data can be assigned only to plugged submodules. </p>
<p class="endli"></p>
</li>
</ul>
<p><b>I/O data buffers</b></p>
<p>The PROFINET protocol uses a cyclic process data model to exchange process data between an IO-controller and an IO-device. The application is responsible for updating the input process data, which is periodically sent to the controller. As well as updating the outputs, regarding to output process data, which is periodically received from the controller. </p>
<p>The application must provide memory buffers to the PNIO stack. Those buffers will be used to exchange process data between the application and the stack. This is done by <a class="el" href="group___p_n___a_p_i___d_e_v_gaf6d832aabd671284e4f102f827401720.html#gaf6d832aabd671284e4f102f827401720" title="Set output data triple buffer of IO device.">PN_API_DEV_setOutputDataBuffer()</a> and <a class="el" href="group___p_n___a_p_i___d_e_v_ga48b267a47eb416809f7ff5d3f7772a4f.html#ga48b267a47eb416809f7ff5d3f7772a4f" title="Set input data triple buffer of IO device.">PN_API_DEV_setInputDataBuffer()</a> functions respectively. </p>
<p><b>Note</b>: For historical reasons, both of these APIs require three buffers for triple buffer implementation. Currently the triple buffer is implemented on the PRU level as described in the documentation <a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM64X/08_01_00_36/exports/docs/api_guide_am64x/PROFINET_DEVICE_FWHAL.html#PROFINET_DEVICE_TRIPLE_BUFFER_MANAGEMENT" data-card-appearance="inline">MCU+SDK: Profinet Device FWHAL</a>. Currently same data buffer has to be provided three times per API as done in the example documentation. </p>
<p><b>Submodules </b></p>
<p>The modules and submodules configuration of the IO-device is done in <code>APP_configureSubmodules()</code>. The example application implements a compact PROFINET device. Real Identification is specified during start-up and cannot be re-configured in run-time. </p>
<p><img src="profinet_example_submodules_config_flow.png" alt="Logical device configuration control flow" height="200px" border="1" class="inline"/> </p>
<p><em>Figure 8 - Submodules configuration</em>. </p>
<p><em>Register substitutes</em></p>
<p>The application registers module and submodule substitutes use <a class="el" href="group___p_n___a_p_i___d_e_v_ga1962c19843827da2162962d26197f49c.html#ga1962c19843827da2162962d26197f49c" title="Register an array of module substitutes on stack.">PN_API_DEV_registerModuleSubstitutes()</a> and <a class="el" href="group___p_n___a_p_i___d_e_v_gae10ad2c75e72e1b519fb03291ca07346.html#gae10ad2c75e72e1b519fb03291ca07346" title="Register an array of submodule substitutes on stack.">PN_API_DEV_registerSubmoduleSubstitutes()</a> respectively . This is an <b>optional </b>feature. If substitutes are registered, the stack can autonomously identify the substitute modules and submodules during connection establishment with IO-controller. </p>
<p><em>Plug modules and submodules</em></p>
<p>The example application connects a DAP module with four submodules, and 18 I/O modules with one submodule per module. It is mandatory to have at least one submodule in a module. </p>
<p><b>Note: </b>While plugging the stack maps submodules to process data image using “offset” specification. Therefore it is important to configure the I/O data buffers <b>before</b> plugging submodules. </p>
<p><b>I&amp;M data</b></p>
<p>According to the PROFINET specification every device must have at least one I&amp;M device representative carrier, which supports I&amp;M0-I&amp;M4 data. The application nominates a submodule of the DAP module as I&amp;M device representative. In APP_configureImData() an instance of <a class="el" href="struct_p_n___a_p_i___i_m___s_carrier.html">PN_API_IM_SCarrier</a> is created and passed to the stack. </p>
<p><b>Note</b>: The application is responsible for data consistency between chassis Id of the PDev <a class="el" href="group___p_n___a_p_i___p_d_e_v_ga5e3f38687dd90f32940436a66744caea.html#ga5e3f38687dd90f32940436a66744caea" title="Apply configuration of physical device.">PN_API_PDEV_applyConfiguration()</a> and I&amp;M0 data of the I&amp;M device representative. </p>
<p><b>Note</b>: It is possible to assign I&amp;M carrier to a plugged submodule. Therefore relevant submodules must be plugged prior to I&amp;M configuration. </p>
<p><b>Write Record indication</b></p>
<p>Application registers Write Record indication callback function using <a class="el" href="group___p_n___a_p_i___d_e_v_ga3a7da1d4334cca7e1cef3ad3b8d5d8f1.html#ga3a7da1d4334cca7e1cef3ad3b8d5d8f1" title="Register IO device callback indicating a write record request has been received.">PN_API_DEV_registerWriteRecordIndicatedCallback()</a>. It is done to have a possibility to store writable I&amp;M data permanently. Application callback APP_cbWriteRecordInd() analyzes Record Data index, to identify the type of I&amp;M data to be stored. </p>
<p><b>Apply configuration</b></p>
<p><a class="el" href="group___p_n___a_p_i___d_e_v_gadcde06be376273e582cd661561985eac.html#gadcde06be376273e582cd661561985eac" title="Apply equipment configuration.">PN_API_DEV_applyEquipmentConfiguration()</a> function is called at the end of configuration sequence to let stack execute a basic configuration check. It is recommended to execute this API function after each manipulation on logical device configuration. </p>
<h2><a class="anchor" id="start"></a>
Start</h2>
<p>After finishing configuration application starts the IO-device using two functions: </p>
<ul>
<li>
<p class="startli"></p>
<p class="interli"><a class="el" href="group___p_n___a_p_i___p_d_e_v_gadfd67a4a24baceeeb1fbff8d8722d5fe.html#gadfd67a4a24baceeeb1fbff8d8722d5fe" title="Start physical device, ethernet interface, ip stack, and IO device.">PN_API_PDEV_start()</a> starts the PNIO stack;</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli">APP_pruStart() starts PRU hardware. This function shall be executed after starting the stack; </p>
<p class="endli"></p>
</li>
</ul>
<p>Now the IO-device is running and is visible in the PROFINET network.</p>
<h1><a class="anchor" id="run-time"></a>
Run-time</h1>
<p>After application has started the IO-device, PROFINET communication is handled by the stack and runs transparently. From PROFINET point of view application is responsible for updating the process data images and providing such callbacks as for permanent data manipulation or LED signalization. </p>
<h2><a class="anchor" id="main_task"></a>
Main task</h2>
<p>Application executes APP_runProfinetStack() in the main task loop. </p>
<p>Here it gets output data received from the controller using <a class="el" href="group___p_n___a_p_i___d_e_v_ga8c2d85d6f1884de354bcd64eb3a2f909.html#ga8c2d85d6f1884de354bcd64eb3a2f909" title="Get buffer of output data triple buffer of IO device with last written output data.">PN_API_DEV_getBufferOutputData()</a>. Application updates input process data image as well. This is being done by getting input buffer from stack <a class="el" href="group___p_n___a_p_i___d_e_v_gabb5eaefdc1bf4024c05b380e3998ef2a.html#gabb5eaefdc1bf4024c05b380e3998ef2a" title="Get buffer of input data triple buffer of IO device for next to be written input data.">PN_API_DEV_getBufferInputData()</a>, manipulating buffer data and subsequent buffer release <a class="el" href="group___p_n___a_p_i___d_e_v_ga7686028cd50c515ea2ddd1e699df583a.html#ga7686028cd50c515ea2ddd1e699df583a" title="Release buffer of input data triple buffer of IO device.">PN_API_DEV_releaseBufferInputData()</a>. </p>
<p>Additionally stack must be regularly triggered using <a class="el" href="group___p_n___a_p_i___p_d_e_v_ga952cd15569b2aa2ca6ac3549ac94fed3.html#ga952cd15569b2aa2ca6ac3549ac94fed3" title="Run physical device, ethernet interface, ip stack, and IO device.">PN_API_PDEV_run()</a>. </p>
<h2><a class="anchor" id="led_task"></a>
LED task</h2>
<p>LED task is a service task, which is responsible for LEDs control:</p>
<h3><a class="anchor" id="system_failure_led"></a>
System Failure LED</h3>
<p>APP_updateSysFailureLedFromPNState() checks the run state of the PROFINET device using <a class="el" href="group___p_n___a_p_i___d_e_v_ga65d9d4466b84f7cc5c7162fdc43d710e.html#ga65d9d4466b84f7cc5c7162fdc43d710e" title="Get IO device run state.">PN_API_DEV_getRunState()</a>. If device is running, i.e. there is a communication established, the LED is permanently OFF. Otherwise it is flashing red. </p>
<h3><a class="anchor" id="dcp_signal_led"></a>
DCP Signal LED</h3>
<p>APP_updateDcpSignalLed() controls DCP Signal LED, depending on <code>dcpSignalLedBlinkingState_s</code> flag. This flag is being updated by the stack, which uses APP_UI_cbDcpSignal() callback for this purpose. For more information refer to <a class="el" href="compact_device_example.html#cyclic_data_communication">Cyclic data communication (Process Data Inputs/Outputs)</a> section of this document. </p>
<h3><a class="anchor" id="cyclic_leds"></a>
Cyclic LEDs (Process Output Data LEDs)</h3>
<p>APP_updateCyclicLedsFromPD() reflects the status of the first byte of the output process data image, as described in <a class="el" href="compact_device_example.html#dcp_signal_indication">DCP Signal indication</a> section of this document. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
